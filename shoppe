#!/usr/bin/env bash
# shellcheck disable=SC1090,SC2001,SC1091,SC2219
##
## shoppe - a portable package manager that integrates with your current package manager
version="1.1.1"
##
## Licensed under the MIT License

## Code guidelines
# Comments for sections will use double hash symbols.
# Single comments will use single hash symbols.
# Use if statements for longer commands and things that require if;else statements.
# For small statements (usually under 3 longer commands) use [[ statement ]] && command1 && command2
# Do not leave empty lines after comments, unless the comments are important in some way.

### BEGIN CODE ###

## Architecture detection.
arch="$(uname -m)"
# Some architectures are mostly the same, and major package managers
# will consider them as the same architecture, so we follow suit.
[[ "$arch" = "i"*"86" ]] && arch="i386"

## Prefixes
# These are used to prefix command output.
p_success="\033[32;1m||\033[0m"
p_info="\033[34;1m::\033[0m"
p_warn="\033[33;1m!!\033[0m"
p_error="\033[31;1m!!\033[0m"
p_debug="\033[35;1m~!\033[0m"

## Configuration. This is overwritten by the main config file ($configdir/config)
configdir="$HOME/.config/shoppe"
repolist="$configdir/repositories"
pkglist="$configdir/pkglist"
deplist="$configdir/deplist"
providedpkglist="$providedpkglist"
pkginfo="$configdir/pkginfo"
tmpdir="/tmp/shoppe"

force="false"
skiperrors="false"

[[ ! -e "$HOME/.config" ]] && mkdir "$HOME/.config"
[[ -e "$configdir/config" ]] && source "$configdir/config"
[[ ! -e "$configdir" ]] && mkdir -p "$configdir"
[[ ! -e "$pkginfo" ]] && mkdir "$pkginfo"
[[ ! -e "$configdir/repodata" ]] && mkdir "$configdir/repodata"
[[ ! -e "$repolist" ]] && echo "http: https://raw.githubusercontent.com/shoppepm/shoppe-repos/master" > "$repolist"
[[ ! -e "$pkglist.frontend" ]] && touch "$pkglist.frontend"
[[ ! -e "$pkglist" ]] && echo "shoppe 0 $version" > "$pkglist"
! grep '^shoppe ' "$pkglist" &>/dev/null && echo "shoppe 0 $version" >> "$pkglist"

## Help (--help)
shoppe_help() { echo "\
Usage: shoppe function [options]

shoppe is a portable package manager that uses the system's native
package manager to suppliment packages that are not available in
shoppe's repositories. It can act as a frontend for most package
managers, and also works as a package manager itself.

It can serve as an alternative to projects like snap or flatpak,
as it allows packages to be installed on multiple distributions
without having to create separate packages for each distribution.
Unlike these projects, however, shoppe is not sandboxed,
and everything is installed natively.

More documentation is available at /usr/share/doc/shoppe.

Commands:

	install <packages>
		Installs packages. This automatically takes care of full (prebuilt)
		packages and shoppepkg files.

	remove <packages>
		Removes packages.

	update
		Updates repository data.

	upgrade
		Upgrades all packages.

	info <packages>
		Shows information about a package. You can also use 'info installed'
		to show all installed packages.

	listall
		Lists all installed packages.

	addrepo <repositories>
		Adds a repository (or multiple repositories). Automatically
		chooses the repository type.

	help
		Displays a short summary of available commands.

Options:

	-h, --help
		Displays a short summary of available commands and exits.

	-v, --version
		Displays the current version and exits.

	-s, --skip-frontend
		Forcefully skips the frontend.

	-c, --skip-frontend-for-chosen-packages
		Forcefully skips the frontend, but only for packages that
		have been specified in the command (so in a command like
		'shoppe install pkg1 pkg2' pkg1 and pkg2 will be skipped
		by the frontend, but their dependencies will not).

	-y, --noconfirm
		Automatically answers all prompts.

	-f, --force
		Forces certain commands and skips certain checks.

	-b, --forcebuild
		Forces packages to be built manually.

	-p, --packagemake
		Creates a package.

	--skip-errors
		Do not when errors occur. Not reccomended.
"
exit 0
}

## Helper functions

sudosu() {
	# Run commands with su root -c 'commands'
	su root -c "$*"
}

auth_init() {
	# This function is used to figure out what authentication methods are available.
	# This is used to replace sudo, as it is not present on all systems and is not required when the user is already root.
	# Usage: auth_init
	# Using authentication: $suauth commands
	[[ "$EUID" -eq 0 ]] && return 0 # User is running as root, no authentication is required.
	command -v "cygstart" &>/dev/null && suauth="cygstart --action=runas" && return 0 # cygwin is being used and cygstart is available
	command -v "sudo" &>/dev/null && suauth="sudo" && return 0 # sudo is available
	command -v "su" &>/dev/null && suauth="sudosu" && return 0
	fail "No authentication methods found! If you have a sudo alternative, add it to the auth_init command and make a pull request."
}

yesno() {
	case $1 in
		y|Y) yesnochoice="[Y/n]";;
		n|N) yesnochoice="[y/N]";;
		*) echo -e "$p_debug yesno function called without a default choice! This will break with noconfirm. Please use yesno <defaultchoice> where defaultchoice is y or n.";;
	esac
	if [[ "$noconfirm" == "true" ]]; then
		echo "$yesnotxt $yesnochoice $1"
		choice="$1"
	else
		read -p "$yesnotxt $yesnochoice " -re choice
	fi
	if [[ "$choice" == "Y" || "$choice" == "y" ]]; then choice="yes"; else choice="no"; fi
}
fail() {
	# Usage: fail <message>
	echo -e "$p_error $*"
	if [[ "$skiperrors" == "true" ]]; then echo -e "$p_warn --skip-errors passed, skipping error."; else exit 1; fi
}
wget --show-progress &> "$tmpdir/wgettest"
grep "unrecognized option" "$tmpdir/wgettest" &>/dev/null && noshowprogress="true"
httpfetch() {
	# This is a frontend for wget, and might support curl in the future as well.
	if [[ "$noshowprogress" == "true" ]]; then wget -q $*; else wget -q --progress=bar:force --show-progress $*; fi
}
# shellcheck disable=SC2154
get_source() {
	# This is a function used to get the source from the source variable.
	# See docs/shoppepkg.md
    if [[ "$sourcetype" == "compressed" ]]; then
        case $source in
            *.tar.gz) sourcetype="targz";;
            *.tar) sourcetype="tar";;
            #*.gz) sourcetype="gz";;
            *.tar.xz) sourcetype="tarxz";;
			*.zip) sourcetype="zip"
        esac
    fi
    # shellcheck disable=SC2154
    case $sourcetype in
        git) git clone "$source" "source";;
        git-tag) git clone --branch "$tag" "$source" "source";;
        tar) httpfetch "$source"; mkdir source; tar xvf ./* -C source;;
        targz) httpfetch "$source"; mkdir source; tar xzf ./* -C source;;
        #gz) httpfetch "$source"; gunzip ./*;;
        tarxz) httpfetch "$source"; mkdir source; tar xJf ./* -C source;;
		zip) httpfetch "$source"; mkdir source; unzip ./* -d source;;
    esac
}

pkg_fetch() {
	# This is an internal function for fetching a package.
	# It is not meant to be called with multiple packages.
	# Usage: package="packagetofetch" pkg_fetch
	# Usage example: use in 'for' loops
	current_uptodate="false"
	success="0"
	repoID=0
	echo -e "$p_info Fetching package: $package"
	if [[ "$command" != "shoppe_upgrade" ]] && [[ "$package" == *".tar.gz" ]]; then
		[[ "$package" = *"http"*"://"* ]] && httpfetch "$package"
		newpackage="$(basename ${package/\.tar\.gz})"
		mkdir "$tmpdir/$newpackage"
		if tar -xf "$package" -C "$tmpdir/$newpackage"; then
			tocheck="${tocheck/$package/$newpackage}"
			package="$newpackage"
			return 0
		else
			fail "Failed to extract $package."
		fi
	fi
	[[ "$command" != "shoppe_upgrade" ]] && [[ -f "$package" ]] && [[ "$package" != *".tar.gz" ]] && [[ "$package" != "shoppe" ]] && grep "pkgname=" "$package" && echo "nobuild='false'" >> "$package" && mkdir "$tmpdir/$package" && cp "$package" "$tmpdir/$package/shoppepkg" && package="$(basename $package)" && return 0
	[[ ! -e "$tmpdir/$package" ]] && mkdir "$tmpdir/$package"
	while IFS="" read -r repo || [[ -n "$repo" ]]; do
		let repoID++
		if grep "^$package " "$configdir/repodata/$repoID" &>/dev/null; then
			reposwithpkg="$reposwithpkg $repoID"
		fi
	done < "$repolist"
	reposwithpkg=$(echo "$reposwithpkg" | sed -e 's/^[ \t]*//')
	[[ -z "$reposwithpkg" ]] && fail "Could not find package $package. Check if your spelling is correct or add a repository that contains this package."
	[[ "$command" != "shoppe_info" ]] && bestline=$(grep "^$package " "$pkglist")
	[[ -z "$bestline" ]] && bestline="$package 0 0"
	originalline="$bestline"
	for repo in $reposwithpkg; do
		# Check which repo contains the highest version.
		# To do this, loop over every repository with the package,
		# get the version in the repo and compare it to a variable
		# which contains the current highest available version.
		# If it's bigger, overwrite that variable and overwrite
		# a variable which contains the previous highest repo.
		currentline=$(grep "^$package " "$configdir/repodata/$repo")
		# shellcheck disable=SC2086
		if [[ "$currentline" != "$bestline" ]] && [[ "$(echo $currentline | awk '{print $3;}' | sed 's/[^0-9]*//g')" -gt "$(echo $bestline | awk '{print $3;}' | sed 's/[^0-9]*//g')" ]] && [[ "$(echo $currentline | awk '{print $2;}')" -ge "$(echo $bestline | awk '{print $2;}')" ]]; then
			bestline="$currentline"
			bestrepo="$repo"
		elif [[ "$currentline" != "bestline" ]] && [[ "$(echo $currentline | awk '{print $3;}')" == "$(echo $bestline | awk '{print $3;}')" ]] && [[ "$(echo $currentline | awk '{print $2;}')" -gt "$(echo $bestline | awk '{print $2;}')" ]]; then
			bestline="$currentline"
			bestrepo="$repo"
		fi
	done
	[[ "$bestline" == "$originalline" ]] && [[ "$command" != "shoppe_info" ]] && current_uptodate="true" && return 0
	repo=$(echo "$bestrepo" | sed -e 's/^[ \t]*//')
	# shellcheck disable=SC2086
	repotofetch="$(head -n1 $configdir/repodata/$repo)"
	case $repotofetch in
		"local: "*) cp "${repotofetch/local\:\ /}/$package/shoppepkg" "$tmpdir/$package/" && success="1" && [[ "$forcebuild" == "true" ]] && [[ "$packagemake" != "true" ]] && echo "nobuild='false'" >> "$tmpdir/$package/shoppepkg";;
		"http: "*) cp "$configdir/repofiles/$repo/$package/shoppepkg" "$tmpdir/$package/" && success="1" && [[ "$forcebuild" == "true" ]] && [[ "$packagemake" != "true" ]] && echo "nobuild='false'" >> "$tmpdir/$package/shoppepkg";;
		"http-full: "*) httpfetch -q "${repotofetch/http\-full\:\ /}/$package/shoppepkg" -O "$tmpdir/$package/shoppepkg" && success="1" && [[ "$forcebuild" == "true" ]] && [[ "$packagemake" != "true" ]] && echo "nobuild='false'" >> "$tmpdir/$package/shoppepkg";;
		*) echo -e "$p_debug Repo data file for id $repo does not contain repository path! Have you been tampering with the file? Run shoppe update to fix this.";;
	esac
	if [[ "$success" == "1" ]]; then return 0; else return 1; fi
}

pkg_fetch_content() {
	# This is a function used to fetch the content-$arch.tar.gz of a package.
	# Before this function, pkg_fetch pulled the content as well.
	# Considering the usual usage of pkg_fetch (fetch package info
	# before progressing with the actual install process) downloading
	# the content-$arch.tar.gz before the user confirmed the installation
	# process is kind of a waste of bandwitdh and time.
	# Thus, the function was split.
	# Usage: package="packagetofetch" pkg_fetch_content
	# Usage example: use in for loops
	[[ "$forcebuild" == "true" ]] && return 0
	[[ -e "$tmpdir/$package/content-$arch.tar.gz" ]] && return 0 # already unpacked in pkg_fetch
	success="0"
	case $repotofetch in
		"local: "*) [[ -e "${repotofetch/local\:\ /}/$package/content-$arch.tar.gz" ]] && cp "${repotofetch/local\:\ /}/$package/content-$arch.tar.gz" "$tmpdir/$package/" && success='1';;
		"http: "*|"http-full: "*)  if httpfetch -q "${repotofetch/http\:\ /}/$package/content-$arch.tar.gz" -O "$tmpdir/$package/content-$arch.tar.gz"; then success='1'; else echo -e "$p_warn Prebuilt files not found, defaulting to build mode..." && echo "nobuild='false'" >> "$tmpdir/$package/shoppepkg"; fi;;
		*) echo -e "$p_debug Repo data file for id $repo does not contain repository path! Have you been tampering with the file? Run shoppe update to fix this.";;
	esac
	if [[ "$success" == "1" ]]; then return 0; else return 1; fi
}

# Package helper functions

pkg_cleanup() {
	# This function cleans up after a shoppe package.
	# Use this when you're running a loop that sources multiple shoppepkgs.
	# Usage: pkg_cleanup
	unset pkgname pkgdesc pkgarch pkgver revision license url depends optional makedepends provides conflicts archdependent source sourcetype tag
	unset -f shoppepkg_preinstall shoppepkg_build shoppepkg_postinstall
	[[ "$currentskipfrontend" == "true" ]] && [[ -z "$pm" ]] && pm="$oldpm"
	unset nobuild current_uptodate currentskipfrontend
	[[ "$forcebuild" == "true" ]] && nobuild="false"
}

pkg_install() {
	# This is an internal function used to install packages.
	# Usage: package="packagetoinstall" pkg_install
	pkg_cleanup
	nobuild="true"
	cd "$tmpdir/$package" || fail "Could not get into temporary directory for $package. Make sure that you didn't wipe your temporary directory during the install process and that you can write to the temporary directory (currently $tmpdir)."
	source shoppepkg
	[[ "$forcebuild" == "true" ]] && nobuild="false"
	# shellcheck disable=SC2154
	[[ "$package" != "$pkgname" ]] && echo -e "$p_debug Package name and pkgname do not match (expected $package, got $pkgname). Please contact the package's maintainer."
	contentdir="$tmpdir/$package/content"
	sourcedir="$tmpdir/$package/source"
	type -t shoppepkg_preinstall &>/dev/null && echo -e "  - $p_info Running pre-install..." && shoppepkg_preinstall
	if [[ "$nobuild" == "false" ]]; then
		type -t shoppepkg_build &>/dev/null && echo -e "  - $p_info Building..." && ! shoppepkg_build && fail "Failed to build $package."
		cd "$tmpdir/$package"
	else
		contentchecksumvar="content_${arch}_checksum"
		mkdir "$tmpdir/$package/content"
		# shellcheck disable=SC2154
		if [[ "$(sha512sum content-$arch.tar.gz | sed 's/\*/\ /g')" == "${!contentchecksumvar}" ]]; then
			! tar -xzf content-$arch.tar.gz -C "$tmpdir/$package/content" && fail "Failed to extract $package."
		else
			echo -e "$p_warn Package checksum (${!contentchecksumvar}) does not match the content tarball's checksum ($(sha512sum content-$arch.tar.gz | sed 's/\*/\ /g'))."
			yesnotxt="Install anyways (not reccomended)?" yesno n
			if [[ "$choice" == "yes" ]]; then
				if tar -xzf content-$arch.tar.gz -C "$tmpdir/$package/content"; then
					echo -e "$p_info Successfully extracted package."
				else
					fail "Failed to extract $package."
				fi
			else
				fail "Failed to install $package."
			fi
		fi
	fi
	! cd content && fail "Failed to install $package."
	! $suauth cp -rf . / && fail "Failed to install $package."
	cd "$tmpdir/$package"
	[[ -e "$pkginfo/$package" ]] && rm -rf "${pkginfo:?}/${package:?}"
	mkdir "$pkginfo/$package"
	shopt -s globstar
	[[ -e "$pkginfo/$package/content" ]] && rm "$pkginfo/$package/content"
	for file in "$tmpdir/$package/content"/**; do
		# This doesn't include directories that are made by the package,
		# but that's still better than adding the entire / directory.
		[[ -f "$file" ]] && echo "${file/$PWD\/content/}" >> "$pkginfo/$package/content"
	done
	shopt -u globstar
	type -t shoppepkg_postinstall &>/dev/null && echo -e "  - $p_info Running post-install..." && ! shoppepkg_postinstall && echo -e "$p_warn Post-install script failed, but package's files were already copied! It is reccomended to reinstall the package, and if that doesn't help, contact the package's maintainer."
	if grep "^$package " "$pkglist" &>/dev/null; then
		sed "/^$package\ /d" "$pkglist" > "${pkglist}-tmp"
		mv "${pkglist}-tmp" "$pkglist"
	fi
	# shellcheck disable=SC2154
	echo "$package $pkgrel $pkgver" >> "$pkglist"
	# shellcheck disable=SC2154
	if grep "^$package " "$deplist" &>/dev/null; then
		sed "/^$package\ /d" "$deplist" > "${deplist}-tmp"
		mv "${deplist}-tmp" "$deplist"
	fi
	[[ "$depends" ]] && echo "$depends " >> "$pkginfo/$package/dependencies" && for dep in $depends; do echo "$dep " >> "$deplist"; done
	[[ "$nobuild" == "false" ]] && [[ "$makedepends" ]] && echo "$makedepends " >> "$pkginfo/$package/dependencies" && for dep in $makedepends; do echo "$dep " >> "$deplist"; done
	[[ "$provides" ]] && echo "$provides " >> "$pkginfo/$package/provides" && for prov in $provides; do echo "$prov " >> "$providedpkglist"; done
	return 0
}

pkg_remove() {
	# This is an internal function used to remove packages.
	# Usage: package="packagetoremove" pkg_remove
	pkg_cleanup
	! xargs $suauth rm -f < "$pkginfo/$package/content" && fail "Failed to remove $package."
	rm -rf "${pkginfo:?}/${package:?}"
	[[ -e "$pkginfo/$package/provides" ]] && for prov in $(cat "$pkginfo/$package/provides"); do sed "s/$prov/g" "$providedpkglist" > "$tmpdir/temp-ppl" && mv "$tmpdir/temp-ppl" "$providedpkglist"; done
	sed "/^$package\ /d" "$pkglist" > "${pkglist}-tmp"
	mv "${pkglist}-tmp" "$pkglist"
}

## Frontend

# Supported package managers:
availablePM="pkg zypper apt apt-get dnf yum yay yaourt pacaur pacman apk eopkg nopmfound"

# shellcheck disable=SC2086
apt_query() {
	# Workaround for buggy apt-cache behavior (apt-cache will return 0 even if the search has failed).
	# Usage: apt_query <package>
	apt-cache search --names-only "$1" &>"$tmpdir/err"
	if [[ -z "$(cat $tmpdir/err)" ]]; then return 1; else return 0; fi
}

yay_query() {
	# Workaround for buggy yay behavior (yay will return 0 even if the search has failed).
	# Usage: yay_query <package>
	yay -Ss "$1" &>"$tmpdir/err"
	if [[ -z "$(cat $tmpdir/err)" ]]; then return 1; else return 0; fi
}

frontend_init() {
	# This function initializes the frontend.
	# Usage: frontend_init
	# See docs/frontend.md
	[[ "$skipfrontend" == "true" ]] && return 0
	for pm in $availablePM; do
		command -v "$pm" &>/dev/null && break
	done
	case $pm in
		nopmfound) # No package manager found
			pm="";;
		pkg) # pkg (Termux, Debian-based with custom frontend)
			frontend_install="$pm install"
			frontend_remove="$pm remove"
			frontend_update="$pm update"
			frontend_upgrade="$pm upgrade"
			frontend_query="apt_query"
			frontend_listall="apt-cache pkgnames" # TODO: This only shows package names but not versions. Fix that, eventually.
			frontend_noconfirm="--yes --force-yes"
			;;
		apt|apt-get) # apt/apt-get (Debian-based)
			frontend_install="$suauth $pm install"
			frontend_remove="$suauth $pm remove"
			frontend_update="$suauth $pm update"
			frontend_upgrade="$suauth $pm upgrade"
			frontend_query="apt_query"
			frontend_listall="apt-cache pkgnames" # TODO: This only shows package names but not versions. Fix that, eventually.
			frontend_noconfirm="--yes --force-yes"
			;;
		dnf|yum) # dnf/yum (Fedora, CentOS, Red Hat and related)
			frontend_install="$suauth $pm install"
			frontend_remove="$suauth $pm remove"
			frontend_update="$suauth $pm update"
			frontend_upgrade="$suauth $pm upgrade"
			frontend_query="$pm search"
			frontend_listall="rpm -qa | sed -i 's/\:/\ 0\ /g'"
			frontend_noconfirm="-y"
			;;
		yay|yaourt|pacaur) # AUR helpers (Arch Linux)
			frontend_install="$pm -Sy --needed"
			frontend_remove="$pm -R"
			frontend_update="$pm -Sy"
			frontend_upgrade="$pm -Syu"
			frontend_query="yay_query"
			frontend_listall="$pm -Q"
			frontend_noconfirm="--noconfirm"
			;;
		pacman) # pacman (Arch Linux)
			frontend_install="$suauth $pm -Sy --needed"
			frontend_remove="$suauth $pm -R"
			frontend_update="$suauth $pm -Sy"
			frontend_upgrade="$suauth $pm -Syu"
			frontend_query="$suauth $pm -Ss"
			frontend_listall="$pm -Q"
			frontend_noconfirm="--noconfirm"
			;;
		zypper) # zypper (openSUSE-based)
			frontend_install="$suauth $pm install"
			frontend_remove="$suauth $pm remove"
			frontend_update="$suauth dnf clean expire-cache && $suauth dnf check-update"
			frontend_upgrade="$suauth $pm update"
			frontend_query="$pm info"
			frontend_listall="rpm -qa --qf '%{NAME}\n'"
			frontend_noconfirm="--non-interactive"
			;;
		apk) # apk (Alpine Linux, postmarketOS)
			frontend_install="$suauth $pm add"
			frontend_remove="$suauth $pm del"
			frontend_update="$suauth $pm update"
			frontend_upgrade="$suauth $pm upgrade"
			frontend_query="$pm info"
			frontend_listall="$pm info" # TODO: Fancy sed command that moves the version to the end and revision to the middle (use apk info -v for that)
			;;
		eopkg) # eopkg (Solus)
			frontend_install="$suauth $pm install"
			frontend_remove="$suauth $pm remove"
			frontend_update="$suauth $pm update-repo"
			frontend_upgrade="$suauth $pm upgrade"
			frontend_query="$suauth $pm info"
			frontend_listall="$suauth $pm list-installed"
			;;
	esac
	if [[ "$noconfirm" == "true" ]] && [[ "$frontend_noconfirm" ]]; then
		if [[ "$pm" == "zypper" ]]; then
			# Zypper requires --non-interactive to be placed before the main command.
			frontend_install="$suauth $pm $frontend_noconfirm install"
			frontend_remove="$suauth $pm $frontend_noconfirm remove"
			frontend_upgrade="$suauth $pm $frontend_noconfirm upgrade"
		else
			frontend_install="$frontend_install $frontend_noconfirm"
			frontend_remove="$frontend_remove $frontend_noconfirm"
			frontend_upgrade="$frontend_upgrade $frontend_noconfirm"
		fi
	fi
}

frontend_harvest() {
	# This function harvests data from the available frontend.
	# Usage: frontend_harvest
	[[ -z "$pm" ]] && return 0
	$frontend_listall > "$pkglist.frontend"
}
## Main functions

# Install packages.
shoppe_install() {
	# Usage: installs packages specified in the $packages variable.
	rm -rf "$tmpdir"
	mkdir -p "$tmpdir"
	[[ -z "$packages" ]] && fail "Nothing to install!"
	[[ ! -e "$configdir/repodata/1" ]] && echo -e "$p_warn No repositories fetched. Running update..." && shoppe_update
#	totalrepos="$(find $configdir/repodata -mindepth 1 -type f | wc -l)" # total amount of repositories
	tocheck="$packages" && oldpm="$pm"
	# Until there's nothing to scan, get each package to scan and:
	# - see if the package is actually available in any repository
	# - fetch the package
	# - source it and add dependencies to the list of packages to be checked
	# - check if the package is already installed
	until [[ -z "${tocheck// }" ]]; do
		for package in $tocheck; do
			pkg_cleanup
			success="0"
			[[ "$skipfrontendforchosenpkgs" == "true" ]] && [[ "$packages" == *"$package"* ]] && currentskipfrontend="true" && unset pm
			[[ "$pm" ]] && $frontend_query ^$package$ &>/dev/null && tofrontend="$tofrontend $package" && tocheck="${tocheck/$package/}" && continue
			[[ -z "$pm" ]] && command -v "$package" &>/dev/null && echo -e "$p_info Package $package is already installed, skipping..." && tocheck="${tocheck/$package/}" && continue
			pkg_fetch
			source "$tmpdir/$package/shoppepkg" &>/dev/null
			[[ "$package" == *"-git" ]] && [[ "$forcebuild" != "true" ]] && [[ "$nobuild" != "true" ]] && echo -e "$p_info $package will be built manually." && echo "nobuild='false'" >> "$tmpdir/$package/shoppepkg" && nobuild=false
			if [[ "$force" != "true" ]]; then
				for conflictpkg in $conflicts $provides; do
					if grep "^$conflictpkg " "$pkglist" &>/dev/null || grep "^$conflictpkg " "$pkglist.frontend" &>/dev/null; then fail "Package $package conflicts with $conflictpkg. Exiting..."; fi
				done
				if [[ "$current_uptodate" == "true" ]]; then
					if grep "^$package " "$deplist" &>/dev/null; then
						echo -e "$p_info Package $package was installed as a dependency. Setting as manually installed and skipping install..."
						sed "/^$package\ /d" "$deplist" > "${deplist}-tmp"
						mv "${deplist}-tmp" "$deplist"
					else
						echo -e "$p_info Package $package is already installed, skipping..."
					fi
					tocheck="${tocheck/$package/}"
					continue
				fi
				if [[ "$pm" ]] && grep "^$package $pkgrel $pkgver" "$pkglist.frontend" &>/dev/null; then
					echo -e "$p_info Package $package is already installed via frontend, skipping..."
					tocheck="${tocheck/$package/}"
					continue
				fi
				if grep "$package" "$providedpkglist" &>/dev/null; then
					echo -e "$p_info Package $package was already provided by another package. Skipping..."
					tocheck="${tocheck/$package/}"
					continue
				fi
			fi
			toinstall="$toinstall $package"
			[[ "$depends" ]] && tocheck="$tocheck $depends"
			[[ "$nobuild" == "false" ]] && [[ "$makedepends" ]] && tocheck="$tocheck $makedepends"
			tocheck="${tocheck/$package/}"
			[[ "$currentskipfrontend" == "true" ]] && pm="$oldpm"
		done
	done
	toinstall="$(echo -e "${toinstall}" | sed -e 's/^[[:space:]]*//')"
	tofrontend="$(echo -e "${tofrontend}" | sed -e 's/^[[:space:]]*//')"
	[[ -z "$toinstall" ]] && [[ -z "$tofrontend" ]] && fail "Nothing to install!"
	[[ "$toinstall" ]] && echo -e "  $p_info This will install the following packages:\n$toinstall"
	[[ "$tofrontend" ]] && echo -e "  $p_info Using frontend for:\n$tofrontend"
	yesnotxt="Continue?" yesno y
	[[ "$choice" == "no" ]] && exit 1
	# shellcheck disable=SC2086
	[[ "$tofrontend" ]] && echo -e "$p_info Installing packages from frontend..." && if $frontend_install $tofrontend; then echo -e "$p_info Updating installed package list..." && frontend_harvest; else fail "Failed to install."; fi
	for package in $toinstall; do
		echo -e "$p_info Fetching prebuilt files..."
		[[ "$packagemake" != "true" ]] && [[ "$nobuild" != "false" ]] && ! pkg_fetch_content && echo -e "$p_warn No prebuilt files found. This is most likely an issue with the package. If you're a package maintainer, use the +pm switch while building, and extract the resulting content-$arch.tar.gz from the package. If you don't want the package to have prebuilt files, add 'nobuild=false' to the shoppepkg, or in case of building from a git repository rather than a static release, add -git to the end of your package name. shoppe will now attempt to install the package, however makedepends were not installed, so this is likely going to fail." && nobuild="false" && echo "nobuild='false'" >> "$tmpdir/$package/shoppepkg"
		echo -e "$p_info Installing $package..."
		let currentpkg++
		! pkg_install && fail "Failed to install $package."
		if [[ "$packagemake" == "true" ]]; then
			cd "$tmpdir/$package/content"
			tar -czf content-$arch.tar.gz .
			sed "/content\_${arch}\_checksum/d" "$tmpdir/$package/shoppepkg" > "$tmpdir/$package/shoppepkg.tmp"
			[[ "$pkgrel" != "rolling" ]] && sed "/pkgrel/d" "$tmpdir/$package/shoppepkg" > "$tmpdir/$package/shoppepkg.tmp"
			mv "$tmpdir/$package/shoppepkg.tmp" "$tmpdir/$package/shoppepkg"
			echo "content_${arch}_checksum='$(sha512sum content-$arch.tar.gz)'" >> "$tmpdir/$package/shoppepkg"
			[[ "$pkgrel" != "rolling" ]] && echo "pkgrel='$pkgrel'" >> "$tmpdir/$package/shoppepkg"
			mkdir "$tmpdir/$package/topackage"
			mv content-$arch.tar.gz "$tmpdir/$package/topackage"
			mv "$tmpdir/$package/shoppepkg" "$tmpdir/$package/topackage"
			tar -czf "$HOME/$package.tar.gz" -C "$tmpdir/$package/topackage" .
			echo -e "$p_debug Package created. Path: $HOME/$package.tar.gz"
		fi
	done
	echo -e "$p_success Installation succeeded."
	exit 0
}

# Remove packages.
shoppe_remove() {
	[[ -z "$packages" ]] && fail "Nothing to remove!"
	tocheck="$packages"
	oldpm="$pm"
	until [[ -z "${tocheck// }" ]]; do
		for package in $tocheck; do
			unset currentfrontend
			[[ "$skipfrontendforchosenpkgs" == "true" ]] && [[ "$packages" == *"$package"* ]] && currentskipfrontend="true" && unset pm
			if [[ "$pm" ]]; then
				! grep "^$package " "$pkglist" &>/dev/null && ! grep "^$package " "$pkglist.frontend" &>/dev/null && echo -e "$p_info Package $package is not installed, skipping..." && tocheck="${tocheck/$package/}" && continue
			else
				! grep "^$package " "$pkglist" &>/dev/null && echo -e "$p_info Package $package is not installed, skipping..." && tocheck="${tocheck/$package/}" && continue
			fi
			# If the package:
			# - isn't set as installed manually
			# - is a dependency to another package
			# it will be skipped, unless the user provides the --force switch.
			if [[ "$force" != "true" ]]; then
				grep "^$package " "$deplist" &>/dev/null && tocheck="${tocheck/$package/}" && continue
				for dir in "$pkginfo"/*; do
					if [[ "$(basename $(dirname $dir))" != "$package" ]] && [[ -e "$dir/dependencies" ]] && grep "^$package " "$dir/dependencies" &>/dev/null; then
						tocheck="${tocheck/$package/}"
						cont="true"
						break
					fi
				done
				[[ "$cont" == "true" ]] && continue
			fi
			grep "^$package " "$deplist" &>/dev/null && tocheck="${tocheck/$package/}" && continue
			grep "^$package " "$pkglist.frontend" &>/dev/null && tofrontend="$tofrontend $package" && currentfrontend="true"
			tocheck="${tocheck/$package/}"
			# shellcheck disable=SC2086
			[[ "$currentfrontend" != "true" ]] && tocheck="$tocheck $(cat $pkginfo/$package/dependencies | tr '\n' ' ')" && toremove="$package"
			[[ "$currentskipfrontend" == "true" ]] && pm="$oldpm"
		done
	done
	[[ -z "$toremove" ]] && [[ -z "$tofrontend" ]] && fail "Nothing to remove!"
	echo -e "$p_info The following packages will be removed:"
	echo "$toremove"
	[[ "$pm" ]] && [[ "$tofrontend" ]] && echo -e "$p_info Using frontend for:" && echo "$tofrontend"
	yesnotxt="Continue?" yesno y
	[[ "$choice" == "no" ]] && exit 1
	# shellcheck disable=SC2086
	[[ "$tofrontend" ]] && echo -e "$p_info Removing packages via frontend..." && if $frontend_remove $tofrontend; then frontend_harvest; else fail "Failed to remove."; fi
	for package in $toremove; do
		echo -e "$p_info Removing $package..."
		! pkg_remove && fail "Failed to remove $package."
	done
	echo -e "$p_success Removal succeeded."
	exit 0
}

# Update repository info.
shoppe_update() {
	[[ "$pm" ]] && echo -e "$p_info Fetching installed package list from frontend..." && frontend_harvest
	[[ "$pm" ]] && $frontend_update
	rm -rf "$configdir/repodata"
	mkdir "$configdir/repodata"
	# For each repository, check the repository type and fetch it accordingly.
	while IFS="" read -r line || [[ -n "$line" ]]; do
		# See also: docs/repositories.md
		if [[ "$line" == "local: "* ]] || [[ "$line" == "http: "* ]] || [[ "$line" == "http-full: "* ]]; then
			success="0"
			let repoID++
			echo -e "$p_info Fetching repository $repoID..."
			case $line in
				"local: "*) cp "${line/local\:\ /}/pkglist" "$configdir/repodata/$repoID" && echo "$line" > "$configdir/repodata/tmp" && cat "$configdir/repodata/$repoID" >> "$configdir/repodata/tmp" && mv "$configdir/repodata/tmp" "$configdir/repodata/$repoID" && success="1" && echo -e "$p_info $repoID is $line";;
				"http: "*) mv "$configdir/repodata/$repoID" "$configdir/repodata/$repoID-old" &>/dev/null; httpfetch -q "${line/http\:\ /}/pkglist" -O "$configdir/repodata/$repoID" && while read -re httpparse; do ! grep "$httpparse" "$configdir/repodata/$repoID-old" &>/dev/null && toparse="$toparse $(echo $httpparse | head -n1 | awk '{print $1;}')"; done < "$configdir/repodata/$repoID" && rm -rf "$configdir/repofiles/$repoID" && mkdir -p "$configdir/repofiles/$repoID" && echo -e "$p_info Fetching packages..." && for t in $toparse; do mkdir -p "$configdir/repofiles/$repoID/$t"; httpfetch "${line/http\:\ /}/$t/shoppepkg" -O "$configdir/repofiles/$repoID/$t/shoppepkg"; done && echo "$line" > "$configdir/repodata/tmp" && cat "$configdir/repodata/$repoID" >> "$configdir/repodata/tmp" && mv "$configdir/repodata/tmp" "$configdir/repodata/$repoID" &&  success="1" && echo -e "$p_debug $repoID is $line";;
				"http-full: "*) httpfetch -q "${line/http\-full\:\ /}/pkglist" -O "$configdir/repodata/$repoID" && echo "$line" > "$configdir/repodata/tmp" && cat "$configdir/repodata/$repoID" >> "$configdir/repodata/tmp" && mv "$configdir/repodata/tmp" "$configdir/repodata/$repoID" &&  success="1" && echo -e "$p_debug $repoID is $line";;
			esac
			[[ "$success" == "0" ]] && let repoID-- && fail "Failed to fetch repository: $line"
		fi
	done < "$repolist"
	[[ "$repoID" == "0" ]] && fail "No repositories were fetched."
	echo -e "$p_success Update succeeded."
	# shoppe_update is often called in functions, so this has to be return and not exit:
	return 0
}

# Upgrade packages
shoppe_upgrade() {
	shoppe_update
	rm -rf "$tmpdir"
	mkdir -p "$tmpdir"
	while IFS="" read -r line || [[ -n "$line" ]]; do
		# shellcheck disable=SC2086
		package="$(echo $line | awk '{print $1;}')"
		pkg_fetch
		[[ "$current_uptodate" != "true" ]] && toupgrade="$toupgrade $package"
	done < "$pkglist"
	toupgrade="$(echo -e "${toupgrade}" | sed -e 's/^[[:space:]]*//')"
	[[ -z "$toupgrade" ]] && echo -e "$p_info Nothing to upgrade." && exit 0
	echo -e "$p_info The following packages will be upgraded:"
	echo "$toupgrade"
	[[ "$pm" ]] && echo -e "$p_info This will also upgrade all packages using the system's native package manager."
	yesnotxt="Continue?" yesno y
	[[ "$choice" == "no" ]] && exit 1
	[[ "$pm" ]] && $frontend_upgrade
	for package in $toupgrade; do
		echo -e "$p_info Fetching prebuilt files..."
		pkg_fetch_content
		echo -e "$p_info Upgrading $package..."
		#! pkg_remove && fail "Failed to upgrade $package."
		! pkg_install && fail "Failed to upgrade $package."
	done
	echo -e "$p_success Upgrade succeeded."
	exit 0
}

# shellcheck disable=SC2154,SC2086
shoppe_info() {
	[[ -z "$packages" ]] && fail "No packages to display!"
	if [[ "$packages" == "installed" ]]; then
		unset packages
		while read -r listline; do
			packages="$packages $(echo $listline | awk '{print $1;}')"
		done < "$pkglist"
	fi
	for package in $packages; do
		forcebuild="true"
		! pkg_fetch && fail "Package $package does not exist!"
		source "$tmpdir/$package/shoppepkg"
		echo -e "$p_info Information about $package:"
		grep "^$package " "$pkglist" &>"$tmpdir/pkgline" && echo -e "[Installed] ($(cat $tmpdir/pkgline))"
		echo -e "Version: $pkgver (package revision $pkgrel)"
		echo -e "License: $license"
		[[ "$depends" ]] && echo -e "Dependencies: $depends"
		[[ "$makedepends" ]] && echo -e "Make dependencies: $makedepends"
		[[ "$optdepends" ]] && echo -e "Optional dependencies: $optdepends"
		[[ "$provides" ]] && echo -e "Provides packages: $provides"
	done
	return 0
}

shoppe_listall() {
	cat "$pkglist"
	return 0
}

shoppe_fetch() {
	# Fetches package files for packages
	# Usage: packages="<packages>" shoppe_fetch
	# Using this in shoppe code is not recommended. Please use fetch <package> instead.
	for package in $packages; do pkg_fetch "$package"; done
	echo -e "$p_success Fetch finished."
	exit 0
}

shoppe_addrepo() {
	for repo in $packages; do
		if [[ "$repo" == "http"*"://"* ]]; then
			echo "http: $repo" >> "$repolist"
		elif [[ -d "$repo" ]]; then
			echo "local: $repo" >> "$repolist"
		else
			fail "Failed to add repository $repo."
		fi
	done
	echo -e "$p_success Repositories added."
}

## Option parsing
[[ -z $1 ]] && fail "Nothing to do! Use 'shoppe help' for information about available commands." && exit 1
case $1 in
		'install') command="shoppe_install";;
		'remove') command="shoppe_remove";;
		'update') command="shoppe_update";;
		'upgrade') command="shoppe_upgrade";;
		'fetch') command="shoppe_fetch";;
		'info') command="shoppe_info";;
		'listall') command="shoppe_listall";;
		'addrepo') command="shoppe_addrepo";;
		'help'|'--help'|'-h'|'+help'|'+h') shoppe_help;;
		'--version'|'-v'|'version') echo "shoppe $version"; exit 0;;
		*) fail "Invalid command: $1. Use 'shoppe help' for information about available commands."; exit 1;;
esac
nocmd="${*/$1/}"
for parse in $nocmd; do
	case $parse in
		+*) echo -e "$p_warn '+' switches are being deprecated. Please use their full switch alternatives instead. See shoppe help"; switches="$switches $parse";;
		-*) switches="$switches $parse";;
		*) packages="$packages $parse";;
	esac
done
command=$(echo "$command" | sed -e 's/^[ \t]*//')
packages=$(echo "$packages" | sed -e 's/^[ \t]*//')
switches=$(echo "$switches" | sed -e 's/^[ \t]*//')
for switch in $switches; do
	if [[ "$switch" != "--"* ]] && [[ "${#switch}" != "2" ]]; then
		switches="${switches/$switch/}"
		switchcheck=$(echo "$switch" | sed -e 's/\(.\)/\1\ /g')
		for toconvert in $switchcheck; do
			[[ "$toconvert" != "-" ]] && switches="$switches -$toconvert"
		done
		switches=$(echo "$switches" | sed -e 's/^[ \t]*//')
	fi
done
for switch in $switches; do
	case $switch in
		'+skipfrontend'|'+sf'|'--skip-frontend'|'-s') skipfrontend="true";;
		'--skip-frontend-for-chosen-packages'|'-c') skipfrontendforchosenpkgs="true";;
		'+skiperrors'|'+se'|'--skip-errors') skiperrors="true";;
		'+noconfirm'|'+nc'|'--noconfirm'|'-y') noconfirm="true";;
		'+forcebuild'|'+fb'|'--forcebuild'|'-b') nobuild="false"; forcebuild="true";;
		'+packagemake'|'+pm'|'--packagemake'|'-p') packagemake="true"; nobuild="false"; forcebuild="true";;
		'+f'|'+force'|'--force'|'-f') force="true";;
		'+h'|'+help'|'--help'|'-h') shoppe_help;;
		'+version'|'+v'|'--version'|'-v') echo "shoppe $version"; exit 0;;
	esac
done
auth_init
[[ "$skipfrontend" != "true" ]] && frontend_init
$command
exit 0
nobuild='false'
nobuild='false'
