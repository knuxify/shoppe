#!/usr/bin/env bash
# shellcheck disable=SC1090,SC2001,SC1091,SC2219
##
## shoppe - a portable package manager that integrates with your current package manager
version="1.0"
##
## Licensed under the MIT License

## Code guidelines
# Comments for sections will use double hash symbols.
# Single comments will use single hash symbols.
# Use if statements for longer commands and things that require if;else statements.
# For small statements (usually under 3 longer commands) use [[ statement ]] && command1 && command2
# Do not leave empty lines after comments, unless the comments are important in some way.

## TODO
# Fix upgrades
# Implement optional dependencies
# Add portable packages (tar files that contain shoppepkg and content.tar.gz)
# (at this point rewrite will be moved to master, and the old master will be moved to legacy)
# Add more authentication methods for commands that use sudo
# Clear up documentation

### BEGIN CODE ###

## Architecture detection.
arch="$(uname -m)"
# Some architectures are mostly the same, and major package managers
# will consider them as the same architecture, so we follow suit.
[[ "$arch" = "i"*"86" ]] && arch="i386"

## Prefixes
# These are used to prefix command output.
p_info="\033[34m::\033[0m"
p_warn="\033[33m!!\033[0m"
p_error="\033[31m!!\033[0m"
p_debug="\033[35m~!\033[0m"

## Warn when running as root.
[[ "$EUID" -eq 0 ]] && echo -e "$p_warn Please refrain from using shoppe as root. Things will most likely break."

## Configuration. This is overwritten by the main config file ($configdir/config)
configdir="$HOME/.config/shoppe"
repolist="$configdir/repositories"
pkglist="$configdir/pkglist"
pkginfo="$configdir/pkginfo"
tmpdir="$configdir/tmp"

force="false"

[[ ! -e "$HOME/.config" ]] && mkdir "$HOME/.config"
[[ -e "$configdir/config" ]] && source "$configdir/config"
[[ ! -e "$configdir" ]] && mkdir -p "$configdir"
[[ ! -e "$pkginfo" ]] && mkdir "$pkginfo"
[[ ! -e "$configdir/repodata" ]] && mkdir "$configdir/repodata"
[[ ! -e "$repolist" ]] && echo "http: https://raw.githubusercontent.com/shoppepm/shoppe-repos/master" > "$repolist"
[[ ! -e "$pkglist.frontend" ]] && touch "$pkglist.frontend"
[[ ! -e "$pkglist" ]] && touch "$pkglist"

## Help (--help)
shoppe_help() { echo "\
Usage: shoppe function [options]

Shoppe is a portable package manager that uses the system's native
package manager to suppliment packages that are not available in
shoppe's repositories. It can act as a frontend for most package
managers, and also works as a package manager itself.

It can serve as an alternative to projects like snap or flatpak,
as it allows packages to be installed on multiple distributions
without having to create separate packages for each distribution.
Unlike these projects, however, shoppe is not sandboxed,
and everything is installed natively.

More documentation is available at /usr/share/doc/shoppe.

Commands:

	install
		Installs packages.

	remove
		Removes packages.

	update
		Updates repository data.

	upgrade
		Upgrades all packages.

	info
		Shows information about a package.

	listall
		Lists all installed packages.

	help
		Displays a short summary of available commands.

Options:

	+nc, +noconfirm, --noconfirm, -y
		Automatically answers all prompts.

	+force, +f, --force, -f
		Forces certain commands.

	+sf, +skipfrontend
		Skips the frontend.

	+h, +help, -h, --help
		Displays a short summary of available commands.

	+fb, +forcebuild
		Forces packages to be built manually.

	+pm, +packagemake
		Creates a package.
"
exit 0
}

## Helper functions
yesno() {
	case $1 in
		y|Y) yesnochoice="[Y/n]";;
		n|N) yesnochoice="[y/N]";;
		*) echo -e "$p_debug yesno function called without a default choice! This will break with noconfirm. Please use yesno <defaultchoice> where defaultchoice is y or n.";;
	esac
	read -p "$yesnotxt $yesnochoice " -re choice
	if [[ "$choice" == "Y" || "$choice" == "y" ]]; then choice="yes"; else choice="no"; fi
}

# shellcheck disable=SC2154
get_source() {
	# This is a function used to get the source from the source variable.
	# See docs/shoppepkg.md
    if [[ "$sourcetype" == "compressed" ]]; then
        case $source in
            *.tar.gz) sourcetype="targz";;
            *.tar) sourcetype="tar";;
            #*.gz) sourcetype="gz";;
            *.tar.xz) sourcetype="tarxz";;
        esac
    fi
    # shellcheck disable=SC2154
    case $sourcetype in
        git) git clone "$source" "source";;
        git-tag) git clone --branch "$tag" "$source" "source";;
        tar) wget "$source"; tar xvf ./* -C source;;
        targz) wget "$source"; tar xzf ./* -C source;;
        #gz) wget "$source"; gunzip ./*;;
        tarxz) wget "$source"; tar xJf ./* -C source;;
    esac
}

pkg_fetch() {
	# This is an internal function for fetching a package.
	# It is not meant to be called with multiple packages.
	# Usage: pkg_fetch <package>
	# Usage example: use in 'for' loops
	current_uptodate="false"
	success="0"
	[[ -z "$1" ]] && echo -e "$p_debug No package to fetch! This is most likely an issue with the code."
	[[ "$2" ]] && echo -e "$p_debug fetch function called with multiple packages! Only downloading $1. Consider using a for loop."
	package="$1"
	repoID=0
	echo -e "$p_info Fetching package: $package"
	while IFS="" read -r repo || [[ -n "$repo" ]]; do
		let repoID++
		if grep "^$package " "$configdir/repodata/$repoID" &>/dev/null; then
			reposwithpkg="$reposwithpkg $repoID"
		fi
	done < "$repolist"
	[[ -z "$reposwithpkg" ]] && echo -e "$p_error Could not find package $package. Check if your spelling is correct or add a repository that contains this package." && exit 1
	bestline=$(grep "^$package " "$pkglist")
	[[ -z "$bestline" ]] && bestline="$package 0 0"
	originalline=$(grep "^$package " "$configdir/repodata/$repo")
	bestline="$originalline"
	for repo in $reposwithpkg; do
		# Check which repo contains the highest version.
		# To do this, loop over every repository with the package,
		# get the version in the repo and compare it to a variable
		# which contains the current highest available version.
		# If it's bigger, overwrite that variable and overwrite
		# a variable which contains the previous highest repo.
		currentline=$(grep "^$package " "$configdir/repodata/$repo")
		# shellcheck disable=SC2086
		if [[ "$currentline" != "$bestline" ]] && [[ "$(echo $currentline | awk '{print $3;}' | sed 's/[^0-9]*//g')" -gt "$(echo $bestline | awk '{print $3;}' | sed 's/[^0-9]*//g')" ]] && [[ "$(echo $currentline | awk '{print $2;}')" != "$(echo $bestline | awk '{print $2;}')" ]]; then
			bestline="$currentline"
			bestrepo="$repo"
		fi
	done
	repo="$bestrepo"
	# shellcheck disable=SC2086
	repotofetch="$(head -n1 $configdir/repodata/$repo)"
	[[ "$bestline" == "$originalline" ]] && echo -e "$p_info $package is already up to date." && current_uptodate="true" && return 0
	mkdir "$tmpdir/$package"
	case $repotofetch in
		"local: "*) cp "${repotofetch/local\:\ /}/$package/shoppepkg" "$tmpdir/$package/" && success="1" && [[ "$forcebuild" == "true" ]] && echo "nobuild='false'" >> "$tmpdir/$package/shoppepkg"
					! [[ "$forcebuild" == "true" ]] && [[ -e "${repotofetch/local\:\ /}/$package/content.tar.gz" ]] && cp "${repotofetch/local\:\ /}/$package/content.tar.gz" "$tmpdir/$package/";;
		"http: "*)  wget -q "${repotofetch/http\:\ /}/$package/shoppepkg" -O "$tmpdir/$package/shoppepkg" && success="1" && [[ "$forcebuild" == "true" ]] && echo "nobuild='false'" >> "$tmpdir/$package/shoppepkg"
					! [[ "$forcebuild" == "true" ]] && ! wget -q "${repotofetch/http\:\ /}/$package/content.tar.gz" -O "$tmpdir/$package/content.tar.gz" && echo -e "$p_warn Prebuilt files not found, defaulting to build mode..." && echo "nobuild='false'" >> "$tmpdir/$package/shoppepkg";;
		*) echo -e "$p_debug Repo data file for id $repo does not contain repository path! Have you been tampering with the file? Run shoppe update to fix this.";;
	esac
	if [[ "$success" == "1" ]]; then return 0; else return 1; fi
}

# Package helper functions

pkg_cleanup() {
	# This function cleans up after a shoppe package.
	# Use this when you're running a loop that sources multiple shoppepkgs.
	# Usage: pkg_cleanup
	unset pkgname pkgdesc pkgarch pkgver revision license website depends optional makedepends conflicts archdependent source sourcetype tag
	unset -f shoppepreinstall shoppebuild shoppeinstall shoppepostinstall
	unset nobuild
	[[ "$forcebuild" == "true" ]] && nobuild="false"
}

pkg_install() {
	# This is an internal function used to install packages.
	# Usage: package="packagetoinstall" pkg_install
	pkg_cleanup
	nobuild="true"
	! cd "$tmpdir/$package" && echo -e "$p_error Could not get into temporary directory for $package. Make sure that you didn't wipe your temporary directory during the install process and that you can write to the temporary directory (currently $tmpdir)." && exit 1
	source shoppepkg
	[[ "$forcebuild" == "true" ]] && nobuild="false"
	# shellcheck disable=SC2154
	[[ "$package" != "$pkgname" ]] && echo -e "$p_debug Package name and pkgname do not match (expected $package, got $pkgname). Please contact the package's maintainer."
	type -t shoppepreinstall &>/dev/null && echo -e "  - $p_info Running pre-install..." && shoppepreinstall
	if [[ "$nobuild" == "false" ]]; then
		type -t shoppebuild &>/dev/null && echo -e "  - $p_info Building..." && ! shoppebuild && echo -e "$p_error Failed to build $package." && exit 1
		type -t shoppeinstall &>/dev/null && echo -e "  - $p_info Installing..." && ! shoppeinstall && echo -e "$p_error Failed to build $package." && exit 1
	else
		# shellcheck disable=SC2154
		[[ "$nobuild" == "true" ]] && [[ "$(sha512sum content.tar.gz)" == "$sha512sum" ]] && tar -xzf content.tar.gz
	fi
	! sudo cp -rf content/* / && echo -e "$p_error Failed to install $package." && exit 1
	[[ -e "$pkginfo/$package" ]] && rm -rf "${pkginfo:?}/${package:?}"
	mkdir "$pkginfo/$package"
	shopt -s globstar
	[[ -e "$pkginfo/$package/content" ]] && rm "$pkginfo/$package/content"
	for file in "$tmpdir/$package/content"/**; do
		echo "${file/$PWD/}" >> "$pkginfo/$package/content"
	done
	shopt -u globstar
	type -t shoppepostinstall &>/dev/null && echo -e "  - $p_info Running post-install..." && ! shoppepostinstall && echo -e "$p_warn Post-install script failed, but package's files were already copied! It is reccomended to reinstall the package, and if that doesn't help, contact the package's maintainer."
	if grep "^$package " "$pkglist"; then
		grep -vwE "^$package " "$pkglist" > "${pkglist}-tmp"
		mv "${pkglist}-tmp" "$pkglist"
	fi
	# shellcheck disable=SC2154
	echo "$package $revision $pkgver" >> "$pkglist"
	# shellcheck disable=SC2154
	if [[ "$nobuild" == "false" ]] && [[ "$makedepends" ]]; then [[ "$depends" ]] && echo "$makedepends $depends" > "$pkginfo/$package/dependencies"; else [[ "$depends" ]] && echo "$depends" > "$pkginfo/$package/dependencies"; fi
}

pkg_remove() {
	# This is an internal function used to remove packages.
	# Usage: package="packagetoremove" pkg_remove
	pkg_cleanup
	! xargs sudo rm -f < "$pkginfo/$package/content" && echo -e "$p_error Failed to remove $package." && exit 1
	rm -rf "${pkginfo:?}/${package:?}"
	grep -vwE "^$package " "$pkglist" > "${pkglist}-tmp"
	mv "${pkglist}-tmp" "$pkglist"
}

## Frontend

# Supported package managers:
availablePM="apt apt-get dnf yum yay yaourt pacaur pacman zypper apk eopkg"

# shellcheck disable=SC2086
apt_query() {
	# Workaround for buggy apt-cache behavior (apt-cache will return 0 even if the search has failed).
	# Usage: apt_query <package>
	apt-cache search --names-only ^"$1"$ &>"$tmpdir/err"
	if [[ -z "$(cat $tmpdir/err)" ]]; then return 1; else return 0; fi
}

frontend_init() {
	# This function initializes the frontend.
	# Usage: frontend_init
	# See docs/frontend.md
	[[ "$skipfrontend" == "true" ]] && return 0
	for pm in $availablePM; do
		command -v "$pm" &>/dev/null && break
	done
	case $pm in
		apt|apt-get) # apt/apt-get (Debian-based)
			frontend_install="sudo $pm install"
			frontend_remove="sudo $pm remove"
			frontend_update="sudo $pm update"
			frontend_upgrade="sudo $pm upgrade"
			frontend_query="apt_query"
			frontend_listall="apt-cache pkgnames" # TODO: This only shows package names but not versions. Fix that, eventually.
			frontend_noconfirm="--yes --force-yes"
			;;
		dnf|yum) # dnf/yum (Fedora, CentOS, Red Hat and related)
			frontend_install="sudo $pm install"
			frontend_remove="sudo $pm remove"
			frontend_update="sudo $pm update"
			frontend_upgrade="sudo $pm upgrade"
			frontend_query="$pm search"
			frontend_listall="rpm -qa | sed -i 's/\:/\ 0\ /g'"
			frontend_noconfirm="-y"
			;;
		yay|yaourt|pacaur) # AUR helpers (Arch Linux)
			frontend_install="$pm -Sy --needed"
			frontend_remove="$pm -R"
			frontend_update="$pm -Sy"
			frontend_upgrade="$pm -Syu"
			frontend_query="$pm -Q"
			frontend_listall="$pm -Q"
			frontend_noconfirm="--noconfirm"
			;;
		pacman) # pacman (Arch Linux)
			frontend_install="sudo $pm -Sy --needed"
			frontend_remove="sudo $pm -R"
			frontend_update="sudo $pm -Sy"
			frontend_upgrade="sudo $pm -Syu"
			frontend_query="sudo $pm -Q"
			frontend_listall="$pm -Q"
			frontend_noconfirm="--noconfirm"
			;;
		zypper) # zypper (SLES, openSUSE-based)
			frontend_install="sudo $pm install"
			frontend_remove="sudo $pm remove"
			frontend_update="sudo dnf clean expire-cache && sudo dnf check-update"
			frontend_upgrade="sudo $pm update"
			frontend_query="$pm info"
			frontend_listall="rpm -qa | sed -i 's/\:/\ 0\ /g'"
			frontend_noconfirm="--non-interactive"
			;;
		apk) # apk (Alpine Linux, postmarketOS)
			frontend_install="sudo $pm add"
			frontend_remove="sudo $pm del"
			frontend_update="sudo $pm update"
			frontend_upgrade="sudo $pm upgrade"
			frontend_query="$pm info"
			frontend_listall="$pm info" # TODO: Fancy sed command that moves the version to the end and revision to the middle (use apk info -v for that)
			;;
		eopkg) # eopkg (Solus)
			frontend_install="sudo $pm install"
			frontend_remove="sudo $pm remove"
			frontend_update="sudo $pm update-repo"
			frontend_upgrade="sudo $pm upgrade"
			frontend_query="sudo $pm info"
			frontend_listall="sudo $pm list-installed"
			;;
	esac
	if [[ "$noconfirm" == "true" ]] && [[ "$frontend_noconfirm" ]]; then
		frontend_install="$frontend_install $frontend_noconfirm"
		frontend_remove="$frontend_remove $frontend_noconfirm"
		frontend_upgrade="$frontend_upgrade $frontend_noconfirm"
	fi
}

frontend_harvest() {
	# This function harvests data from the available frontend.
	# Usage: frontend_harvest
	[[ -z "$pm" ]] && return 0
	$frontend_listall >> "$pkglist.frontend"
}
## Main functions

# Install packages.
shoppe_install() {
	# Usage: installs packages specified in the $packages variable.
	echo -e "$p_info Searching on shoppe repositories..."
	rm -rf "$tmpdir"
	mkdir "$tmpdir"
	[[ -z "$packages" ]] && echo -e "$p_error Nothing to install!" && exit 1
	[[ ! -e "$configdir/repodata/1" ]] && echo -e "$p_warn No repositories fetched. Running update..." && shoppe_update
#	totalrepos="$(find $configdir/repodata -mindepth 1 -type f | wc -l)" # total amount of repositories
	tocheck="$packages"
	# Until there's nothing to scan, get each package to scan and:
	# - see if the package is actually available in any repository
	# - fetch the package
	# - source it and add dependencies to the list of packages to be checked
	# - check if the package is already installed
	until [[ -z "${tocheck// }" ]]; do
		for package in $tocheck; do
			pkg_cleanup
			success="0"
			[[ "$pm" ]] && $frontend_query "$package" &>/dev/null && tofrontend="$tofrontend $package" && tocheck="${tocheck/$package/}" && continue
			pkg_fetch "$package"
			source "$tmpdir/$package/shoppepkg"
			if [[ "$force" != "true" ]] && grep "^$package $revision $pkgver" "$pkglist" &>/dev/null; then
				echo -e "$p_info Package $package is already installed, skipping..."
				tocheck="${tocheck/$package/}"
				continue
			fi
			if [[ "$pm" ]] && [[ "$force" != "true" ]] && grep "^$package $revision $pkgver" "$pkglist.frontend" &>/dev/null; then
				echo -e "$p_info Package $package is already installed via frontend, skipping..."
				tocheck="${tocheck/$package/}"
				continue
			fi
			toinstall="$toinstall $package"
			[[ "$depends" ]] && tocheck="$tocheck $depends"
			[[ "$nobuild" == "false" ]] && [[ "$makedepends" ]] && tocheck="$tocheck $makedepends"
			tocheck="${tocheck/$package/}"
		done
	done
	toinstall="$(echo -e "${toinstall}" | sed -e 's/^[[:space:]]*//')"
	tofrontend="$(echo -e "${tofrontend}" | sed -e 's/^[[:space:]]*//')"
	[[ -z "$toinstall" ]] && [[ -z "$tofrontend" ]] && echo -e "$p_error Nothing to install!" && exit 1
	[[ "$toinstall" ]] && echo -e "  $p_info This will install the following packages:\n$toinstall"
	[[ "$tofrontend" ]] && echo -e "  $p_info Using frontend for:\n$tofrontend"
	yesnotxt="Continue?" yesno y
	[[ "$choice" == "no" ]] && exit 1
	# shellcheck disable=SC2086
	[[ "$tofrontend" ]] && echo -e "$p_info Installing packages from frontend..." && if $frontend_install $tofrontend; then echo -e "$p_info Updating installed package list..." && frontend_harvest; else echo -e "$p_error Failed to install." && exit 1; fi
	for package in $toinstall; do
		echo -e "$p_info Installing $package..."
		let currentpkg++
		pkg_install
		if [[ "$packagemake" == "true" ]]; then
			tar -czf content.tar.gz content
			echo -e "$p_debug sha512sum=$(sha512sum content.tar.gz)"
			mv content.tar.gz "$HOME/$package.tar.gz"
			echo -e "$p_debug Saved content.tar.gz as $HOME/$package.tar.gz."
		fi
	done
}

# Remove packages.
shoppe_remove() {
	[[ -z "$packages" ]] && echo -e "$p_error Nothing to remove!" && exit 1
	tocheck="$packages"
	until [[ -z "${tocheck// }" ]]; do
		for package in $tocheck; do
			unset currentfrontend
			if [[ "$pm" ]]; then
				! grep "^$package " "$pkglist" &>/dev/null && ! grep "^$package " "$pkglist.frontend" && echo -e "$p_info Package $package is not installed, skipping..." && tocheck="${tocheck/$package/}" && continue
			else
				! grep "^$package " "$pkglist" &>/dev/null && echo -e "$p_info Package $package is not installed, skipping..." && tocheck="${tocheck/$package/}" && continue
			fi
			shopt -s globstar
			for dir in "$pkginfo"/**; do
				if [[ -e "$dir/dependencies" ]] && grep "^$package" "$dir/dependencies"; then
					tocheck="${tocheck/$package/}"
					depfound="true"
					break
				fi
			done
			[[ "$depfound" == "true" ]] && continue
			grep "^$package " "$pkglist.frontend" && tofrontend="$tofrontend $package" && currentfrontend="true"
			tocheck="${tocheck/$package/}"
			# shellcheck disable=SC2086
			[[ "$currentfrontend" != "true" ]] && tocheck="$tocheck $(cat $pkginfo/$package/dependencies)" && toremove="$package"
		done
	done
	[[ -z "$toremove" ]] && [[ -z "$tofrontend" ]] && echo -e "$p_error Nothing to remove!" && exit 1
	echo -e "$p_info The following packages will be removed"
	echo "$toremove"
	[[ "$pm" ]] && [[ "$tofrontend" ]] && echo -e "$p_info Using frontend for:" && echo "$tofrontend"
	yesnotxt="Continue?" yesno y
	[[ "$choice" == "no" ]] && exit 1
	# shellcheck disable=SC2086
	[[ "$tofrontend" ]] && echo -e "$p_info Removing packages via frontend..." && if $frontend_remove $tofrontend; then frontend_harvest; else echo -e "$p_error Failed to remove." && exit 1; fi
	for package in $toremove; do
		echo -e "$p_info Removing $package..."
		pkg_remove
	done
}

# Update repository info.
shoppe_update() {
	[[ "$pm" ]] && echo -e "$p_info Fetching installed package list from frontend..." && frontend_harvest
	[[ "$pm" ]] && $frontend_update
	rm -rf "$configdir/repodata"
	mkdir "$configdir/repodata"
	# For each repository, check the repository type and fetch it accordingly.
	while IFS="" read -r line || [[ -n "$line" ]]; do
		# See also: docs/repositories.md
		if [[ "$line" == "local:"* ]] || [[ "$line" == "http:"* ]]; then
			success="0"
			let repoID++
			echo -e "$p_info Fetching repository $repoID..."
			case $line in
				"local: "*) cp "${line/local\:\ /}/pkglist" "$configdir/repodata/$repoID" && echo "$line" > "$configdir/repodata/tmp" && cat "$configdir/repodata/$repoID" >> "$configdir/repodata/tmp" && mv "$configdir/repodata/tmp" "$configdir/repodata/$repoID" && success="1" && echo -e "$p_info $repoID is $line";;
				"http: "*) wget -q "${line/http\:\ /}/pkglist" -O "$configdir/repodata/$repoID" && echo "$line" > "$configdir/repodata/tmp" && cat "$configdir/repodata/$repoID" >> "$configdir/repodata/tmp" && mv "$configdir/repodata/tmp" "$configdir/repodata/$repoID" &&  success="1" && echo -e "$p_debug $repoID is $line";;
			esac
			[[ "$success" == "0" ]] && let repoID-- && echo -e "$p_warn Failed to fetch repository: $line"
		fi
	done < "$repolist"
	[[ "$repoID" == "0" ]] && echo -e "$p_error No repositories were fetched." && exit 1
	return 0
}

# Upgrade packages
shoppe_upgrade() {
	# I am currently busy fixing other things, so I'll just leave this here:
	echo -e "$p_debug Upgrades are broken and only the frontend will work correctly. This will be fixed soon:tm:"
	shoppe_update
	rm -rf "$tmpdir"
	mkdir "$tmpdir"
	while IFS="" read -r line || [[ -n "$line" ]]; do
		# shellcheck disable=SC2086
		package="$(echo $line | awk '{print $1;}')"
		pkg_fetch "$package"
		[[ "$current_uptodate" != "true" ]] && toupgrade="$toupgrade $package"
	done < "$pkglist"
	toupgrade="$(echo -e "${toupgrade}" | sed -e 's/^[[:space:]]*//')"
	[[ -z "$toupgrade" ]] && echo -e "$p_info Nothing to upgrade." && exit 0
	echo -e "$p_info The following packages will be upgraded:"
	echo "$toupgrade"
	[[ "$pm" ]] && echo -e "$p_info This will also upgrade all packages using the system's native package manager."
	yesnotxt="Continue?" yesno y
	[[ "$choice" == "no" ]] && exit 1
	[[ "$pm" ]] && $frontend_upgrade
	for package in $toupgrade; do
		echo -e "$p_info Upgrading $package..."
		! pkg_remove && echo -e "$p_error Failed to upgrade $package." && exit 1
		! pkg_install && echo -e "$p_error Failed to upgrade $package." && exit 1
	done
}

# shellcheck disable=SC2154,SC2086
shoppe_info() {
	[[ -z "$packages" ]] && echo -e "$p_error No packages to display!"
	for package in $packages; do
		forcebuild="true"
		! pkg_fetch "$package" && echo -e "$p_error Package $package does not exist!" && exit 1
		source "$tmpdir/$package/shoppepkg"
		echo -e "$p_info Information about $package:"
		grep "^$package " "$pkglist" &>"$tmpdir/pkgline" && echo -e "[Installed] ($(cat $tmpdir/pkgline))"
		echo -e "Version: $pkgver (package revision $revision)"
		echo -e "License: $license"
		[[ "$depends" ]] && echo -e "Dependencies: $depends"
		[[ "$makedepends" ]] && echo -e "Make dependencies: $makedepends"
		[[ "$optional" ]] && echo -e "Optional dependencies: $optional"
	done
	return 0
}

shoppe_listall() {
	cat "$pkglist"
	return 0
}

shoppe_fetch() {
	# Fetches package files for packages
	# Usage: packages="<packages>" shoppe_fetch
	# Using this in shoppe code is not recommended. Please use fetch <package> instead.
	for package in $packages; do pkg_fetch "$package"; done
}

## Option parsing
[[ -z $1 ]] && echo -e "$p_error Nothing to do! Use 'shoppe help' for information about available commands." && exit 1
case $1 in
		'install') command="shoppe_install";;
		'remove') command="shoppe_remove";;
		'update') command="shoppe_update";;
		'upgrade') command="shoppe_upgrade";;
		'fetch') command="shoppe_fetch";;
		'info') command="shoppe_info";;
		'listall') command="shoppe_listall";;
		'help'|'--help'|'-h'|'+help'|'+h') shoppe_help;;
		'--version'|'-v'|'version') echo "shoppe $version"; exit 0;;
		*) echo -e "$p_error Invalid command: $1. Use 'shoppe help' for information about available commands."; exit 1;;
esac
nocmd="${*/$1/}"
for parse in $nocmd; do
	case $parse in
		-*) switches="$switches $parse";;
		+*) shoppeswitches="$shoppeswitches $parse";;
		*) packages="$packages $parse";;
	esac
done
command=$(echo "$command" | sed -e 's/^[ \t]*//')
packages=$(echo "$packages" | sed -e 's/^[ \t]*//')
switches=$(echo "$switches" | sed -e 's/^[ \t]*//')
for switch in $shoppeswitches; do
	case $switch in
		"+skipfrontend"|"+sf") skipfrontend="true";;
		"+noconfirm"|"+nc") noconfirm="true";;
		"+forcebuild"|"+fb") nobuild="false"; forcebuild="true";;
		"+packagemake"|"+pm") packagemake="true"; nobuild="false";;
		"+f"|"+force") force="true";;
		'+h'|'+help') shoppe_help;;
		'+version'|'+v') echo "shoppe $version"; exit 0;;
	esac
done
for switch in $switches; do
	case $switch in
		--noconfirm|-y) noconfirm="true";;
		--help|-h) shoppe_help;;
		--force) force="true";;
		'--version'|'-v') echo "shoppe $version"; exit 0;;
	esac
done
[[ "$skipfrontend" != "true" ]] && frontend_init

$command
exit 0
