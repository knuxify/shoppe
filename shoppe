#!/usr/bin/env bash
# shellcheck disable=SC1090,SC2001,SC1091
##
## shoppe - a lightweight portable package manager that integrates with your current package manager
##
## Licensed under the MIT License

## Code guidelines
# Comments for sections will use double hash symbols.
# Single comments will use single hash symbols.
# Use if statements for longer commands and things that require if;else statements.
# For small statements (usually under 3 longer commands) use [[ statement ]] && command1 && command2
# Do not leave empty lines after comments, unless the comments are important in some way.

## TODO
# Add upgrades
# Add basic package search (package search, list all packages)
# Fix package installation order (dependencies first, full packages last)
# Compare package versions between multiple repositories
# Re-add all package managers and add query and listall commands
# (at this point rewrite will be moved to master, and the old master will be moved to legacy)
# More authentication methods for commands that use sudo
# Clear up documentation
# Implement optional dependencies

### BEGIN CODE ###

## Architecture detection.
arch="$(uname -m)"
# Some architectures are mostly the same, and major package managers
# will consider them as the same architecture, so we follow suit.
[[ "$arch" = "i"*"86" ]] && arch="i386"

## Prefixes
# These are used to prefix command output.
p_info="\033[34m::\033[0m"
p_warn="\033[33m!!\033[0m"
p_error="\033[31m!!\033[0m"
p_debug="\033[35m~!\033[0m"

## Warn when running as root.
[[ "$EUID" -eq 0 ]] && echo -e "$p_warn Please refrain from using shoppe as root. Things will most likely break."

## Configuration. This is overwritten by the main config file ($configdir/config)
configdir="$HOME/.config/shoppe"
repofile="$configdir/repositories"
pkglist="$configdir/pkglist"
pkginfo="$configdir/pkginfo"
tmpdir="$configdir/tmp"

force="false"

[[ ! -e "$HOME/.config" ]] && mkdir "$HOME/.config"
[[ ! -e "$configdir" ]] && mkdir "$configdir"
[[ ! -e "$pkginfo" ]] && mkdir "$pkginfo"
[[ -e "$configdir/config" ]] && source "$configdir/config"
[[ ! -e "$configdir/repodata" ]] && mkdir "$configdir/repodata"
[[ ! -e "$repofile" ]] && echo "http: https://raw.githubusercontent.com/shoppepm/shoppe-repos/master" > "$repofile"
[[ ! -e "$pkglist.frontend" ]] && touch $pkglist.frontend

## Helper functions
yesno() {
    if ! [[ "$noconfirm" == "true" ]]; then
        choice=null
        until [[ "$choice" == "y" ]] || [[ "$choice" == "Y" ]] || [[ "$choice" == "n" ]] || [[ "$choice" == "N" ]]; do
            read -p "$yesnotxt" -ren1 choice
            if [ -z "$choice" ]; then choice="$1"; fi
        done
    else
        echo "$yesnotxt$1"
        choice="$1"
    fi
    if [[ "$choice" == "Y" || "$choice" == "y" ]]; then choice="yes"; else choice="no"; fi
}

get_source() {
	# This is a function used to get the source from the source variable.
	# See docs/shoppepkg.md
    if [[ "$sourcetype" == "compressed" ]]; then
        case $source in
            *.tar.gz) sourcetype="targz";;
            *.tar) sourcetype="tar";;
            #*.gz) sourcetype="gz";;
            *.tar.xz) sourcetype="tarxz";;
        esac
    fi
    # shellcheck disable=SC2154
    case $sourcetype in
        git) git clone "$source" "source";;
        git-tag) git clone --branch "$tag" "$source" "source";;
        tar) wget "$source"; tar xvf ./* -C source;;
        targz) wget "$source"; tar xzf ./* -C source;;
        #gz) wget "$source"; gunzip ./*;;
        tarxz) wget "$source"; tar xJf ./* -C source;;
    esac
}

pkg_cleanup() {
	# This function cleans up after shoppe package.
	# Use this when you're running a loop that sources multiple shoppepkgs.
	# Usage: pkg_cleanup
	unset pkgname pkgdesc pkgarch pkgver revision license website depends optional makedepends conflicts archdependent source sourcetype tag
	unset -f shoppepreinstall shoppebuild shoppeinstall shoppepostinstall
	unset nobuild
	[[ "$forcebuild" == "true" ]] && nobuild="false"
}

## Frontend

# Supported package managers:
availablePM="apt apt-get dnf yum yay yaourt pacaur pacman"

apt_query() {
	# Workaround for buggy apt-cache behavior (apt-cache will return 0 even if the search has failed).
	# Usage: apt_query <package>
	apt-cache search --names-only ^"$1"$ &>"$tmpdir/err"
	if [[ -z "$(cat $tmpdir/err)" ]]; then return 1; else return 0; fi
}

frontend_init() {
	# This function initializes the frontend.
	# Usage: frontend_init
	# See docs/frontend.md
	[[ "$skipfrontend" == "true" ]] && return 0
	for pm in $availablePM; do
		command -v "$pm" &>/dev/null && break
	done
	case $pm in
		apt|apt-get)
			frontend_install="sudo $pm install"
			frontend_remove="sudo $pm remove"
			frontend_update="sudo $pm update"
			frontend_upgrade="sudo $pm upgrade"
			frontend_query="apt_query"
			frontend_listall="apt-cache pkgnames" # TODO: This only shows package names but not versions. Fix that, eventually.
			;;
		yay|yaourt|pacaur)
			frontend_install="$pm -Sy --needed"
			frontend_remove="$pm -R"
			frontend_update="$pm -Sy"
			frontend_upgrade="$pm -Syu"
			frontend_query="$pm -Q"
			frontend_listall="$pm -Q"
			;;
		pacman)
			frontend_install="sudo $pm -Sy --needed"
			frontend_remove="sudo $pm -R"
			frontend_update="sudo $pm -Sy"
			frontend_upgrade="sudo $pm -Syu"
			frontend_query="sudo $pm -Q"
			frontend_listall="$pm -Q"
			;;
	esac
}

frontend_harvest() {
	# This function harvests data from the available frontend.
	# Usage: frontend_harvest
	[[ -z "$pm" ]] && return 0
	$frontend_listall >> $pkglist.frontend
}

fetch() {
	# This is an internal function for fetching a package.
	# It is not meant to be called with multiple packages.
	# Usage: fetch <package>
	# Usage example: use in 'for' loops
	[[ -z "$1" ]] && echo -e "$p_debug No package to fetch! This is most likely an issue with the code."
	[[ "$2" ]] && echo -e "$p_debug fetch function called with multiple packages! Only downloading $1. Consider using a for loop."
	echo -e "$p_info Fetching package: $package"
	until [[ ! -e "$configdir/repodata/$idtocheck" ]]; do
		grep "$package" "$configdir/repodata/$idtocheck" &>/dev/null && success="1" && repo="$idtocheck" && break
		let idtocheck++
	done
	[[ "$success" = "0" ]] && echo -e "$p_error Could not find package $package. Check if your spelling is correct or add a repository that contains this package." && exit 1
	repotofetch="$(head -n1 $configdir/repodata/$repo)"
	mkdir "$tmpdir/$package"
	case $repotofetch in
		"local: "*) cp "${repotofetch/local\:\ /}/$package/shoppepkg" "$tmpdir/$package/" && success="1"
					[[ -e "${repotofetch/local\:\ /}/$package/content.tar.gz" ]] && cp "${repotofetch/local\:\ /}/$package/content.tar.gz" "$tmpdir/$package/";;
		"http: "*)  wget -q "${repotofetch/http\:\ /}/$package/shoppepkg" -O "$tmpdir/$package/shoppepkg"
					! wget -q "${repotofetch/http\:\ /}/$package/content.tar.gz" -O "$tmpdir/$package/content.tar.gz" && echo -e "$p_warn Prebuilt files not found, defaulting to build mode..." && echo "nobuild='false'" >> "$tmpdir/$package/shoppepkg";;
		*) echo -e "$p_debug Repo data file for id $repo does not contain repository path! Have you been tampering with the file? Run shoppe update to fix this.";;
	esac
}
## Main functions

# Install packages.
shoppe_install() {
	# Usage: installs packages specified in the $packages variable.
	echo -e "$p_info Searching on shoppe repositories..."
	rm -rf "$tmpdir"
	mkdir "$tmpdir"
	[[ -z "$packages" ]] && echo -e "$p_error Nothing to install!" && exit 1
	[[ ! -e "$configdir/repodata/1" ]] && echo -e "$p_warn No repositories fetched. Running update..." && shoppe_update
#	totalrepos="$(find $configdir/repodata -mindepth 1 -type f | wc -l)" # total amount of repositories
	tocheck="$packages"
	# Until there's nothing to scan, get each package to scan and:
	# - see if the package is actually available in any repository
	# - fetch the package
	# - source it and add dependencies to the list of packages to be checked
	# - check if the package is already installed
	until [[ -z "${tocheck// }" ]]; do
		for package in $tocheck; do
			pkg_cleanup
			success="0"
			idtocheck="1"
			[[ "$pm" ]] && $frontend_query $package &>/dev/null && tofrontend="$tofrontend $package" && tocheck="${tocheck/$package/}" && continue
			fetch $package
			source "$tmpdir/$package/shoppepkg"
			if [[ "$force" != "true" ]] && grep "^$package $revision $pkgver" "$pkglist" &>/dev/null; then
				echo -e "$p_info Package $package is already installed, skipping..."
				tocheck="${tocheck/$package/}"
				continue
				#echo -e "$p_info Package $package is already installed! Install anyways? [y/N]"
				#yesno n
				#[[ "$choice" == "no" ]]  && continue
			fi
			if [[ "$pm" ]] && [[ "$force" != "true" ]] && grep "^$package $revision $pkgver" "$pkglist.frontend" &>/dev/null; then
				echo -e "$p_info Package $package is already installed via frontend, skipping..."
				tocheck="${tocheck/$package/}"
				continue
			fi
			toinstall="$toinstall $package"
			[[ ! -z "$depends" ]] && tocheck="$tocheck $depends"
			[[ "$nobuild" = "false" ]] && [[ ! -z "$makedepends" ]] && tocheck="$tocheck $makedepends"
			tocheck="${tocheck/$package/}"
		done
	done
	toinstall="$(echo -e "${toinstall}" | sed -e 's/^[[:space:]]*//')"
	tofrontend="$(echo -e "${tofrontend}" | sed -e 's/^[[:space:]]*//')"
	[[ -z "$toinstall" ]] && [[ -z "$tofrontend" ]] && echo -e "$p_error Nothing to install!" && exit 1
	echo -e "  $p_info This will install the following packages: "
	echo -e "$toinstall"
	[[ "$tofrontend" ]] && echo -e "  $p_info Using frontend for:\n$tofrontend"
	echo -e "Continue? [Y/n]"
	yesno y
	[[ "$choice" == "no" ]] && exit 1
	[[ "$tofrontend" ]] && echo -e "$p_info Installing packages from frontend..." && if $frontend_install $tofrontend; then echo -e "$p_info Updating installed package list..." && frontend_harvest; else echo -e "$p_error Failed to install." && exit 1; fi
	for package in $toinstall; do
		pkg_cleanup
		echo -e "$p_info Installing $package..."
		let currentpkg++
		nobuild="true"
		cd "$tmpdir/$package"
		source shoppepkg
		[[ "$forcebuild" == "true" ]] && nobuild="false"
		[[ "$package" != "$pkgname" ]] && echo -e "$p_debug Package name and pkgname do not match (expected $package, got $pkgname). Please contact the package's maintainer."
		type -t shoppepreinstall &>/dev/null && echo -e "  - $p_info Running pre-install..." && shoppepreinstall
		if [[ "$nobuild" == "false" ]]; then
			type -t shoppebuild &>/dev/null && echo -e "  - $p_info Building..." && ! shoppebuild && echo -e "$p_error Failed to build $package." && exit 1
			type -t shoppeinstall &>/dev/null && echo -e "  - $p_info Installing..." && ! shoppeinstall && echo -e "$p_error Failed to build $package." && exit 1
		else
			[[ "$nobuild" == "true" ]] && [[ "$(sha512sum content.tar.gz)" == "$sha512sum" ]] && tar -xzf content.tar.gz
		fi
		! sudo cp -rf content/* / && echo -e "$p_error Failed to install $package." && exit 1
		[[ -e "$pkginfo/$package" ]] && rm -rf "$pkginfo/$package"
		mkdir "$pkginfo/$package"
		shopt -s globstar
		[[ -e "$pkginfo/$package/content" ]] && rm "$pkginfo/$package/content"
		for file in "$tmpdir/$package/content"/**; do
			echo "${file/$PWD/}" >> "$pkginfo/$package/content"
		done
		shopt -u globstar
		type -t shoppepostinstall &>/dev/null && echo -e "  - $p_info Running post-install..." && ! shoppepostinstall && echo -e "$p_warning Post-install script failed, but package's files were already copied! It is reccomended to reinstall the package, and if that doesn't help, contact the package's maintainer."
		if grep "^$package " "$pkglist"; then
			grep -vwE "^$package " "$pkglist" > "${pkglist}-tmp"
			mv "${pkglist}-tmp" "$pkglist"
		fi
		echo "$package $revision $pkgver" >> "$pkglist"
		if [[ "$nobuild" == "false" ]] && [[ "$makedepends" ]]; then [[ "$depends" ]] && echo "$makedepends $depends" > "$pkginfo/$package/dependencies"; else [[ "$depends" ]] && echo "$depends" > "$pkginfo/$package/dependencies"; fi
		if [[ "$packagemake" == "true" ]]; then
			tar -czf content.tar.gz content
			echo -e "$p_debug sha512sum=$(sha512sum content.tar.gz)"
			mv content.tar.gz ~/$package.tar.gz
			echo -e "$p_debug Saved content.tar.gz as $HOME/$package.tar.gz."
		fi
	done
}

# Remove packages.
shoppe_remove() {
	[[ -z "$packages" ]] && echo -e "$p_error Nothing to remove!" && exit 1
	tocheck="$packages"
	until [[ -z "${tocheck// }" ]]; do
		for package in $tocheck; do
			unset currentfrontend
			if [[ "$pm" ]]; then
				! grep "^$package " "$pkglist" &>/dev/null && ! grep "^$package " "$pkglist.frontend" && echo -e "$p_info Package $package is not installed, skipping..." && tocheck="${tocheck/$package/}" && continue
			else
				! grep "^$package " "$pkglist" &>/dev/null && echo -e "$p_info Package $package is not installed, skipping..." && tocheck="${tocheck/$package/}" && continue
			fi
			shopt -s globstar
			for dir in $pkginfo/**; do
				if [[ -e "$dir/dependencies" ]] && grep "^$package" "$dir/dependencies"; then
					tocheck="${tocheck/$package/}"
					depfound="true"
					break
				fi
			done
			[[ "$depfound" == "true" ]] && continue
			grep "^$package " "$pkglist.frontend" && tofrontend="$tofrontend $package" && currentfrontend="true"
			tocheck="${tocheck/$package/}"
			[[ "$currentfrontend" != "true" ]] && tocheck="$tocheck $(cat $pkginfo/$package/dependencies)" && toremove="$package"
		done
	done
	[[ -z "$toremove" ]] && [[ -z "$tofrontend" ]] && echo -e "$p_error Nothing to remove!" && exit 1
	echo -e "$p_info The following packages will be removed"
	echo "$toremove"
	[[ "$pm" ]] && [[ "$tofrontend" ]] && echo -e "$p_info Using frontend for:" && echo "$tofrontend"
	echo -e "Continue? [Y/n]"
	yesno y
	[[ "$choice" == "no" ]] && exit 1
	for package in $toremove; do
		pkg_cleanup
		echo -e "$p_info Removing $package..."
		! xargs sudo rm -f < "$pkginfo/$package/content" && echo -e "$p_error Failed to remove $package." && exit 1
		rm -rf "$pkginfo/$package"
		grep -vwE "^$package " "$pkglist" > "${pkglist}-tmp"
		mv "${pkglist}-tmp" "$pkglist"
	done
}

# Update repository info.
shoppe_update() {
	[[ "$pm" ]] && echo -e "$p_info Fetching installed package list from frontend..." && frontend_harvest
	rm -rf "$configdir/repodata"
	mkdir "$configdir/repodata"
	# For each repository, check the repository type and fetch it accordingly.
	while IFS="" read -r line || [[ -n "$line" ]]; do
		# See also: docs/repositories.md
		if [[ "$line" == "local:"* ]] || [[ "$line" == "http:"* ]]; then
			success="0"
			let repoID++
			echo -e "$p_info Fetching repository $repoID..."
			case $line in
				"local: "*) cp "${line/local\:\ /}/pkglist" "$configdir/repodata/$repoID" && echo "$line" > "$configdir/repodata/tmp" && cat "$configdir/repodata/$repoID" >> "$configdir/repodata/tmp" && mv "$configdir/repodata/tmp" "$configdir/repodata/$repoID" && success="1" && echo -e "$p_info $repoID is $line";;
				"http: "*) wget -q "${line/http\:\ /}/pkglist" -O "$configdir/repodata/$repoID" && echo "$line" > "$configdir/repodata/tmp" && cat "$configdir/repodata/$repoID" >> "$configdir/repodata/tmp" && mv "$configdir/repodata/tmp" "$configdir/repodata/$repoID" &&  success="1" && echo -e "$p_debug $repoID is $line";;
			esac
			[[ "$success" == "0" ]] && let repoID-- && echo -e "$p_warn Failed to fetch repository: $line"
		fi
	done < "$repofile"
	[[ "$repoID" == "0" ]] && echo -e "$p_error No repositories were fetched." && exit 1
	return 0
}

shoppe_fetch() {
	# Fetches package files for packages
	# Usage: packages="<packages>" shoppe_fetch
	for package in $packages; do fetch $package +; done
}

## Option parsing
case $1 in
		'install') command="shoppe_install";;
		'remove') command="shoppe_remove";;
		'update') command="shoppe_update";;
		'upgrade') command="shoppe_upgrade";;
		'fetch') command="shoppe_fetch";;
		'query') command="shoppe_query"; subcommand="$2";;
esac
nocmd="${*/$1/}"
nocmd="${nocmd/$subcommand/}"
for parse in $nocmd; do
	case $parse in
		-*) switches="$switches $parse";;
		+*) shoppeswitches="$shoppeswitches $parse";;
		*) packages="$packages $parse";;
	esac
done
command=$(echo "$command" | sed -e 's/^[ \t]*//')
packages=$(echo "$packages" | sed -e 's/^[ \t]*//')
switches=$(echo "$switches" | sed -e 's/^[ \t]*//')
[[ -z $command ]] && echo -e "$p_error Nothing to do!" && exit 1
for switch in $shoppeswitches; do
	case $switch in
		"+skipfrontend"|"+sf") skipfrontend="true";;
		"+noconfirm"|"+nc") noconfirm="true";;
		"+rawquery"|"+rq") rawquery="true";;
		"+forcebuild"|"+fb") nobuild="false"; forcebuild="true";;
		"+packagemake"|"+pm") packagemake="true"; nobuild="false";;
		"+f"|"+force") force="true";;
	esac
done
[[ "$switch" == *"--noconfirm"* ]] && noconfirm="true"

[[ "$skip_frontend" != "true" ]] && frontend_init

$command
