#!/bin/bash
# shellcheck disable=SC2219,SC2001,SC2164,SC2086,SC2181

# shoppe, a lightweight and portable package manager
# maintained by knuxify
version="0.1"

arch="$(uname -m)"
[[ "$arch" = "i"*"86" ]] && arch="i686"
nobuild="true"

# Colors
color() {
	case $1 in
		0) printf "\033[30m";;
		1) printf "\033[31m";;
		2) printf "\033[32m";;
		3) printf "\033[33m";;
		4) printf "\033[34m";;
		5) printf "\033[35m";;
		6) printf "\033[36m";;
		7) printf "\033[37m";;
		r) printf "\033[0m";;
	esac
}
infoPrefix="$(color 4)||$(color r)"
warnPrefix="$(color 3)~!$(color r)"
errorPrefix="$(color 1)!!$(color r)"
debugPrefix="$(color 5)~~$(color r)"

# Don't run shoppe as root!
if [[ "$EUID" -eq 0 ]]; then echo -e "$errorPrefix Don't run shoppe as root!"; exit 4; fi

configdir="$HOME/.config/shoppe"
repofile="$configdir/repos"
configfile="$configdir/config"
packagefile="$configdir/packages"
packinfodir="$configdir/packinfo"
tmpdir="$configdir/tmp"

# Create shoppe files
! [[ -e "$configdir" ]] && mkdir -p "$configdir"
! [[ -e "$repofile" ]] && echo "GithubRepo=shoppepm/shoppe-repos" > "$repofile"
! [[ -e "$packinfodir" ]] && mkdir "$packinfodir"

# TODO package managers
unsupportedManagers="emerge nix-env"

# Detect currently installed package managers
supportedManagers="pkg apt apt-get yum dnf pacman yaourt pacaur yay apk eopkg zypper"

for pm in $supportedManagers; do
	if command -v "$pm" &>/dev/null; then
		installed="$installed $pm"
	fi
done

for pm in $unsupportedManagers; do
	if command -v "$pm" &>/dev/null; then
		echo -e "$warnPrefix Detected a known but unsupported package manager: $pm."
		echo -e "$warnPrefix It might be added in a later update."
	fi
done

yesno() {
	if ! [[ "$noconfirm" == "true" ]]; then
		choice=null
		until [[ "$choice" == "y" ]] || [[ "$choice" == "Y" ]] || [[ "$choice" == "n" ]] || [[ "$choice" == "N" ]]; do
			read -p "$yesnotxt" -ren1 choice
			if [ -z "$choice" ]; then choice="$1"; fi
		done
	else
		echo "$yesnotxt$1"
		choice="$1"
	fi
	if [[ "$choice" == "Y" || "$choice" == "y" ]]; then choice="yes"; else choice="no"; fi
}

getsource() {
	if [[ "$sourcetype" == "compressed" ]]; then
		case $source in
			*.tar.gz) sourcetype="targz";;
			*.tar) sourcetype="tar";;
			*.gz) sourcetype="gz";;
			*.tar.xz) sourcetype="tarxz";;
		esac
	fi
	# shellcheck disable=SC2154
	case $sourcetype in
		git) mkdir "$name"; git clone "$source" "$name";;
		git-tag) mkdir "$name"; git clone --branch "$tag" "$source" "$name";;
		tar) mkdir "$name"; cd "$name"; wget "$source"; tar xvf ./*; cd ..;;
		targz) mkdir "$name"; cd "$name"; wget "$source"; tar xzf ./*; cd ..;;
		gz) mkdir "$name"; cd "$name"; wget "$source"; gunzip ./*; cd ..;;
		tarxz) mkdir "$name"; cd "$name"; wget "$source"; tar xJf ./*; cd ..;;
	esac
}

fetch() {
	# DEV NOTE: This is an internal function used to fetch packages.
	# How to use: Use this when you need to fetch a package from a for loop (for package in $packages).
	dpackage="$(echo $package | sed 's/\s.*$//')"
	for todownload in 'content.tar.gz' shoppepkg; do
		while IFS="" read -r repo; do
			fetchfail=""
			case $repo in
				GithubRepo=*) wget -q "https://raw.githubusercontent.com/${repo/GithubRepo=/}/master/$dpackage/$todownload" -O "$tmpdir/$todownload" && success="true";;
				Local=*) cp -f "${repo/Local=/}/$dpackage/$todownload" "$tmpdir/" &>/dev/null && success="true";;
			esac
		done < $repofile
		[[ "$todownload" == "shoppepkg" ]] && [[ "$success" != "true" ]] && fetchfail="true" && echo -e "$errorPrefix Could not fetch package: $package. Check your spelling or add a repository that contains this package."
	done
}

# Functions
pinstall() {
	[[ -z "$packages" ]] && echo -e "$errorPrefix Nothing to install!" && exit 2
	if [[ "$skipfrontend" != "true" ]] && [[ "$installed" ]]; then
		for pm in $installed; do
			echo -e "$infoPrefix Using $pm..."
			case $pm in
				apt|apt-get|yum|dnf|eopkg|zypper) sudo "$pm" install $packages $switches && break;;
				pkg) "$pm" install $packages $switches && break;;
				pacman) sudo "$pm" -S $packages $switches --needed && break;;
				yaourt|yay) "$pm" -S $packages $switches --needed && break;;
				apk) sudo "$pm" add $packages $switches && break;;
			esac
			echo -e "$warnPrefix $pm failed."
		done
	fi
	echo -e "$infoPrefix Searching on shoppe repositories..."
	currentpack=0
	installsuccess=0
	for package in $packages; do
		if grep "^$package " "$packagefile" &>/dev/null; then
			yesnotxt="$package is already installed! Install anyways? [y/N] "
			yesno n
			if [[ "$choice" == "no" ]]; then continue; else alreadyinstalled="true"; fi
		fi
		rm -rf "$tmpdir"
		mkdir "$tmpdir"
		echo -e "$infoPrefix Installing $package..."
		let currentpack++
		echo -e "  - $infoPrefix Fetching package..."
		fetch
		[[ "$fetchfail" ]] && continue
		[[ "$success" != "true" ]] && continue
		cd "$tmpdir"
		source shoppepkg
		if [[ "$pkgarch" != "all" ]]; then
			validarch="false"
			for procarch in $pkgarch; do
				[[ "$arch" == "$pkgarch" ]] && validarch="true"
			done
			[[ "$validarch" == "false" ]] && echo -e "$errorPrefix Package $pkgname does not support your current architecture (your arch is $arch and this package supports $pkgarch)." && continue
		fi
		conflictsfail=""
		if [[ "$conflicts" ]]; then
			for clash in $conflicts; do
				grep "^$clash " "$packagefile" &>/dev/null && conflictsfail="true" && echo -e "$errorPrefix $pkgname clashes with $clash. Remove clashing packages to be able to install $pkgname."
			done
		fi
		[[ "$conflictsfail" ]] && continue
		currentsuccess=""
		[[ ! -s "content.tar.gz" ]] && echo -e "$warnPrefix No prebuilt files found, defaulting to build mode..." && nobuild="false"
		[[ "$makedepends" ]] && packages="$makedepends" pinstall
		[[ "$depends" ]] && packages="$depends" pinstall
		type -t shoppepreinstall &>/dev/null && echo -e "  - $infoPrefix Running pre-install..." && shoppepreinstall
		if [[ "$nobuild" != "true" ]]; then
			getsource
			echo -e "  - $infoPrefix Building..."
			type -t shoppebuild &>/dev/null && shoppebuild
			echo -e "  - $infoPrefix Installing..."
			type -t shoppeinstall &>/dev/null && shoppeinstall && currentsuccess="1"
		fi
		[[ "$nobuild" == "true" ]] && tar -xzf content.tar.gz && currentsuccess="1"
		type -t shoppepostinstall &>/dev/null && echo -e "  - $infoPrefix Running post-install..." && shoppepostinstall && currentsuccess="1"
		sudo cp -rf "$tmpdir/content"/* /
		shopt -s globstar
		for file in "$tmpdir/content"/**; do
		    [[ ! -d "$file" ]] && echo "${file/$PWD/}" >> "$packinfodir/$pkgname"
		done
		shopt -u globstar
		[[ "$packagemake" == "true" ]] && tar -zcvf "$HOME/$pkgname.tar.gz" content && echo -e "$infoPrefix Saved compressed package as \e[1m$HOME/$pkgname.tar.gz\e[0m."
		# NOTE: Bash <4 friendly method:
		# find ./ -type f | cut -c2- > $packinfodir/$pkgname
		if [[ "$currentsuccess" == "1" ]] && ! [[ "$alreadyinstalled" = "true" ]]; then
			# shellcheck disable=SC2154
			echo "$pkgname $revision" >> $packagefile
		fi
		if [[ "$1" != "up" ]]; then
			nopt=0
			for opt in $optional; do
				let nopt++
				echo "$opt:"; sed -n "$nopt,${nopt}p" optional
			done
		fi
		let installsuccess++
	done
	if [[ "$installsuccess" != "$currentpack" ]]; then
		echo -e "$errorPrefix Failed to install some packages. Double check your spelling."
		exit 1
	else
		echo -e "$infoPrefix Installed succesfully." && exit 0
	fi
}

premove() {
	if [[ -z "$packages" ]]; then echo -e "$errorPrefix Nothing to remove!"; exit 2; fi
	if [[ "$skipfrontend" != "true" ]]; then
		for pm in $installed; do
			echo -e "$infoPrefix Using $pm..."
			case $pm in
				apt|apt-get|yum|dnf|eopkg|zypper) sudo "$pm" remove $packages $switches && success;;
				pkg) "$pm" remove $packages $switches && success;;
				pacman) sudo "$pm" -R $packages $switches && success;;
				yaourt|yay) "$pm" -R $packages $switches && success;;
				apk) sudo "$pm" del $packages $switches && success;;
			esac
			echo -e "$warnPrefix $pm failed."
		done
	fi
	currentpack="0"
	for package in $packages; do
		let currentpack++
		if grep "^$package " "$packagefile" &>/dev/null; then
			[[ "$1" != "up" ]] && echo -e "$infoPrefix Removing package $package..."
			xargs sudo rm -f < "$packinfodir/$package"
			grep -v "^$package " "$packagefile" > "${packagefile}-tmp"
			mv -f "${packagefile}-tmp" "$packagefile"
			rm "$packinfodir/$package"
			name="$package"
			success
			name=""
		fi
	done
	if [[ "$success" != "$currentpack" ]]; then
		echo -e "$errorPrefix Failed to remove some packages. Double check your spelling."
		exit 1
	else
		[[ "$1" != "up" ]] && echo -e "$infoPrefix Removed succesfully." && exit 0
	fi
}

pupgrade() {
	if [[ "$skipfrontend" != "true" ]]; then
		for pm in $installed; do
			echo -e "$infoPrefix Using $pm..."
			case $pm in
				apt|apt-get|yum|dnf|eopkg|zypper|apk) sudo "$pm" upgrade $packages $switches && let success++;;
				pkg) "$pm" upgrade $packages $switches && let success++;;
				pacman) sudo "$pm" -Syu $packages $switches && let success++;;
				yaourt|yay) "$pm" -Syu $packages $switches && let success++;;
			esac
			echo -e "$warnPrefix $pm failed."
		done
	fi
	# shellcheck disable=2094
	while IFS="" read -r package || [ -n "$package" ]; do
		rm -rf "$tmpdir"
		mkdir "$tmpdir"
		fetch
		cd "$tmpdir"
		source shoppepkg
		oldver="$(echo "$package" | sed "s/$pkgname//g")"
		if [[ "$revision" = "rolling" || $revision -gt $oldver ]]; then
			echo -e "$infoPrefix Upgrading $package..."
			skipfrontend="true"
			packages="$package" premove up
			packages="$package" pinstall up
			echo -e "$infoPrefix Done!"
			name="$package"
			success
			name=""
		fi
	done < $packagefile
	if [[ "$success" = "$currentpack" || "$success" -gt "$currentpack" ]]; then
		echo -e "$infoPrefix Upgraded succesfully."
		exit 0
	else
		echo -e "$errorPrefix Failed to upgrade some packages. Double check your spelling."
		exit 1
	fi
}

pupdate() {
	if [[ "$skipfrontend" != "true" ]]; then
		for pm in $installed; do
			echo -e "$infoPrefix Using $pm..."
			case $pm in
				apt|apt-get|yum|dnf|eopkg|zypper|apk) sudo "$pm" update "$switches" && success;;
				pkg) "$pm" update "$switches" && success;;
				pacman) sudo "$pm" -Sy "$switches" && success;;
				yaourt|yay) "$pm" -Sy "$switches" && success;;
			esac
			echo -e "$warnPrefix $pm failed."
		done
		echo -e "$errorPrefix Repo update failed."
	else
		echo -e "$infoPrefix There is no need to update repositories in shoppe."
	fi
}

pquery-info() {
	if [[ -z "${packages/$subcommand/}" ]]; then
		echo -e "$errorPrefix Nothing to query!"
		echo -e "$errorPrefix Available options: query info packages, query info installed"
		exit 2
	fi
	packages="${packages/$subcommand/}"
	packages=$(echo "$packages" | sed -e 's/^[ \t]*//')
	if [[ "$packages" == "installed" ]]; then
		packages=""
		while IFS="" read -r package; do
			packages="$packages $(echo $package | sed 's/\s.*$//')"
		done < $packagefile
		packages=$(echo "$packages" | sed -e 's/^[ \t]*//')
	fi
	for package in $packages; do
		rm -rf "$tmpdir"
		mkdir "$tmpdir"
		fetch
		cd "$tmpdir"
		source shoppepkg
		echo "==="
		echo "$pkgname - $pkgdesc"
		echo "version: $pkgver (package version $revision)"
		echo "Licenced under the $license license"
		echo "Website: $website"
		echo "Dependencies: $depends (make: $makedepends)"
		echo "Optional dependencies: $optional"
	done
}

pquery-packcount() {
	if [[ "$rawquery" != "true" ]]; then
		echo "Package count: $(wc -l $packagefile | awk '{ print $1 }')"
	else
		wc -l $packagefile | awk '{ print $1 }'
	fi
}

pquery-list() {
	if [[ "$rawquery" != "true" ]]; then
		cat $packagefile
	else
		cat $packagefile
	fi
}

pquery() {
	if [[ -z "$subcommand" ]]; then
		echo -e "$errorPrefix No query command given!"
		echo -e "$errorPrefix Available query commands: info, packcount, list"
		exit 2
	else
		case $subcommand in
			'info') pquery-info;;
			'packcount') pquery-packcount;;
			'list') pquery-list;;
		esac
	fi
}

pfetch() {
	echo -e "$infoPrefix Packages will be saved in ~/.shoppe-output."
	rm -rf ~/.shoppe-output
	mkdir ~/.shoppe-output
	for package in $packages; do
		rm -rf "$tmpdir"
		mkdir "$tmpdir"
		fetch
		mkdir "$HOME/.shoppe-output/$package"
		mv "$tmpdir/shoppepkg" "$HOME/.shoppe-output/$package/"
		[[ -e "$tmpdir/content.tar.gz" ]] && mv "$tmpdir/content.tar.gz" "$HOME/.shoppe-output/$package"
		echo -e "$infoPrefix Fetched $package."
	done
}

# Parse options.
case $1 in
		'install') command="install";;
		'remove') command="remove";;
		'update') command="update";;
		'upgrade') command="upgrade";;
		'fetch') command="fetch";;
		'query') command="query"; subcommand="$2";;
		'pkgtools') command="pkgtools"; subcommand="$2";;
esac
nocmd="${*/$command/}"
nocmd="${nocmd/$subcommand/}"
for parse in $nocmd; do
	case $parse in
		-*) switches="$switches $parse";;
		+*) shoppeswitches="$shoppeswitches $parse";;
		*) packages="$packages $parse";;
	esac
done
command=$(echo "$command" | sed -e 's/^[ \t]*//')
packages=$(echo "$packages" | sed -e 's/^[ \t]*//')
switches=$(echo "$switches" | sed -e 's/^[ \t]*//')
if [[ -z $command ]]; then
	echo -e "$errorPrefix Nothing to do!"
	exit 1
fi
for switch in $shoppeswitches; do
	case $switch in
		"+skipfrontend"|"+sf") skipfrontend="true";;
		"+noconfirm"|"+nc") noconfirm="true";;
		"+rawquery"|"+rq") rawquery="true";;
		"+forcebuild"|"+fb") nobuild="false";;
		"+packagemake"|"+pm") packagemake="true"; nobuild="false";;
	esac
done
for switch in $switches; do
	case $switch in
		"--noconfirm") noconfirm="true";;
	esac
done
# Execute required command
#shellcheck disable=SC2086
p$command
